# 菜鸡算法（每日一题）

这总是绕不过去的

## 20210402

### 1.两个栈实现队列

[剑指offer 09]: https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210402203652540.png" alt="image-20210402203652540" style="zoom:80%;" />

垃圾如我，很久才对这样的输入示例看懂，实在是想死。

```java
class CQueue {

    Stack <Integer> stackIn;
    Stack <Integer> stackOut;

    public CQueue() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>();

    }
    
    public void appendTail(int value) {

        // stackIn 的栈顶就是队列的尾部
        // 如果永远不delete，或者查询，stackOut应该是永远为空
        stackIn.push(value);

    }
    
    public int deleteHead() {
        // stackOut取栈顶为队列的头部
        // 一旦要头部信息，就需要把stackIn出栈，并且存放至stackOut
        if(!stackOut.empty()){
            return stackOut.pop();
        }else{
            if(stackIn.empty())
                return -1;
            while(!stackIn.empty()){
                 stackOut.push(stackIn.pop());
            }
                return stackOut.pop();
        }       
    }
}

```

### 2. 栈中的最小元素

[包含min函数的栈]: https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/

```java
class MinStack {

    Stack <Integer> stackIn;
    
    Stack <Integer> stackOut;


    /** initialize your data structure here. */
    public MinStack() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>() ;
    }
    
    // 压栈
    // 并更新最小值
    public void push(int x) {
        stackIn.push(x);
        // 维持着从栈顶到栈底的递增
        if(stackOut.empty() || stackOut.peek() >= x)
            stackOut.push(x);

    }
    
    // 弹出最顶层元素
    // 并更新最小值
    // 弹出的元素如果是最小值,则两边都要弹出
    public void pop() {
       if((stackIn.pop()).equals(stackOut.peek()))
            stackOut.pop();
       
    }
    
    // 返回最顶层元素
    public int top() {
        return stackIn.peek();

    }
    
    public int min() {
        return stackOut.peek();
    }
}
```

## 20210718

### 说明一下图的深度优先搜索

```java
类似于树的先序遍历
    即一直深入到断点 
```

## 一、双指针

### 1. 三数之和

leetcode 15 

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

思路：双指针

如何三个数使用双指针，肯定是遍历数组，==挑出一个数，其他两个数互为相反数==，`其他两个数的遍历使用双指针`

<font color=red>在这之前</font>，要明白，双指针由于有快慢指针之分，或者方向指针之分，其中==方向指针一般适用于有序数组==

<font color=red>这里，我们就需要使用方向指针</font>,即一个left指针，一个right指针。一般是在<font color=red>有序数组</font>上使用。

所以我们`需要对数组排序`

解释以下代码的三个逻辑

1.`nums[left]+nums[right]==target`时，自然`res.add(Arrays.asList(nums[i],nums[left],nums[right]));`

且在这个逻辑下，必须跳过`++left与left对应数组值相等的情况`,同理必须跳过`--right与right对应值相等的情况`

2.在`nums[left]+nums[right]`小于`target`时左移，则`left++`，相反则`right--`

3.很容易忘记的一点是，每次`遍历的第一个数如果和前一个数相同`，应该需要`跳过该数的逻辑以以去重`

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        if(null==nums||nums.length<3){
            return res;
        }
        // 方法一  用set去重  
        // Set<List<Integer>> set=new HashSet<>();

        // 先排序  
        int len=nums.length;
        Arrays.sort(nums);

        // 双指针
        for(int i=0;i<len;i++){
            // 另外的原因  那就是遍历的数与上一个相同
            if(i>0 && nums[i]==nums[i-1]) continue;
            int target=0-nums[i];
            int left=i+1;
            int right=len-1;
            while(right>left){
                if(nums[left]+nums[right]==target){

                    // // set直接去重
                    // set.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    // // 找到了第一个还有别的可能
                    // // 这里是left 和right都变
                    // left++;
                    // right--;

                    // 方法二 跳过去重
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right &&nums[left]==nums[++left]);
                    while(left<right &&nums[right]==nums[--right]);

                }
                if(nums[left]+nums[right]<target){
                    left++;

                }
                if(nums[left]+nums[right]>target){
                    right--;
                    
                }

            }
        }

        // res=new ArrayList<>(set);
        return res;

    }
}
```

### 2. 最接近的三数之和

leetcode16

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/3sum-closest
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

思路：双指针

复用三数之和的逻辑，加上一个==**记录比target大最小正gap和一个比target小的最大负gap**==，即可

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {

        // 排个序是必要的
        Arrays.sort(nums);
        int len=nums.length;
        // 双指针不回头的
               // 问题一 ：可以得到最小的gap，但是最小的gap，结果是比他大还是比他小呢
                // 问题二： 如何去重
        // 问题一：各自记录一个比target小的最大的负数值
        // 和一个比target大的最小的正数值
        int negativeGap=Integer.MIN_VALUE;
        int positiveGap=Integer.MAX_VALUE;
        for(int i=0;i<len;i++){
            // 先记录每次的出发点
            int tmp=nums[i];
            // 问题二：去重方案点一
            if(i>0 && nums[i]==nums[i-1]) continue;
            int left=i+1;
            int right=len-1;
            while(left<right){
                int sum=tmp+nums[left]+nums[right];
                if(sum==target){
                    return target;
                }else{
                    if(sum-target<0){
                        // 说明左边的值太小了
                        // 小的取最大值
                        negativeGap=negativeGap<sum-target?sum-target:negativeGap;
                        // 问题二：去重方案点二
                        while(left<right &&nums[left]==nums[++left]);
                    }else{
                        // 大的取最小值
                        positiveGap=positiveGap>sum-target?sum-target:positiveGap;
                        // 问题二：去重方案点二
                        while(left<right &&nums[right]==nums[--right]);
                        
                    }
                }
            }   
        }
        return negativeGap+positiveGap>0?target+negativeGap:target+positiveGap;
    }
}
```

### 3. 盛最多水的容器

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 说明：你不能倾斜容器。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/container-with-most-water
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211026002958419.png" alt="image-20211026002958419" style="zoom:67%;" />

```java
class Solution {
    public int maxArea(int[] height) {
        //我们移动 数字较小的那个指针
        int len=height.length;
        int left=0;
        int right=len-1;
        int area=0;
        while(left!=right){


            int tmp=(right-left)*Math.min(height[left],height[right]);
            area=Math.max(area,tmp);
            // 总之，移动数字比较小的指针，因为是他在高度方面存在短板，所以要移动
            // 左边的就向右边找
            // 右边的就向左边找
            // 仅此而已
            // mark 2021-10-26
            if(height[left]<height[right]){
                left++;
            }else{
                right--;
            }

        }
        return area;


    }
}
```

### 4. 删除倒数第n个节点

> leetcode-19
>
> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    
    public ListNode removeNthFromEnd(ListNode head, int n) {

        // 快慢指针
        
        // 注意 我们是要找倒数第n个数的前驱  也就是倒数第n+1个节点
        // 快指针为tail的next时，如果快指针比慢指针快n个节点，那么慢指针刚好处于倒数第n个节点
        // 我们想要的是前驱  所以慢指针最好到达倒数第n+1个节点，也就是快指针比慢指针快n+1

        // 所以快指针要先走n+1步
     

        

        // 已经走了一步
        ListNode fast=head;
      
        // 1.初始化 给快指针加速了n步 一共走了n+1步
        while(n>0){
            fast=fast.next;
            n--;
        }

        // 2.如果快指针为空，说明刚好有n个点 则删除头节点  返回头节点的next即可
        if(fast==null) {
            return head.next;
        }

        // 3.让快指针继续走到tail的next，记录步数
        int count=0;
        while(fast!=null){
            fast=fast.next;
            count++;
        }

        // 4. slow先初始化走了一步
        ListNode slow=head;
        count--;
        while(count>0){
            slow=slow.next;
            count--;
        }

        // 5. 此时slow到达倒数第n+1个点处，即前驱,要删除的点的前驱
        ListNode pre=slow;
        ListNode nNode=slow.next;
        ListNode n1Node=slow.next.next;
        pre.next=n1Node;

        // 返回head
        return head;


     
    }
}
```

### 5. 旋转链表的k个节点

> #### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)
>
> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
    if(head==null){
        return null;
    }

    // 1. 计算链表长度 和获取尾部节点
    ListNode tmp=head;
    ListNode tail=null; 
    int len=0;
    while(tmp!=null){
        len++;
        tail=tmp;
        tmp=tmp.next;
    }

    // 2.如果k是长度的整数倍将直接返回即可
    if(k%len==0){
        return head;
    }

    // 3 这里可以大胆的把tail和head连起来,成环了，以后的工作只需要断开即可
    tail.next=head;

    // 4. 假如k大于len 且不是整数倍 比如len=3 k=5
    // 312 231 123 312 231
    // 头部节点落在len-k%len+1
    // 需要找到头部节点的前驱 即len-k%len pre
       // 先res=pre.next
       // pre.next=null;
       // 把tail和head连上即可
       //  return res
    if(k>len){
        int prePosition=len-k%len;
        ListNode pre=head;
        prePosition--;
        while(prePosition>0){
            pre=pre.next;
            prePosition--;
        }
        // 这里已经得到了pre
        ListNode res=pre.next;
        pre.next=null;
        return res;
    }


    // 5.假如k小于len，那么将需要在倒数第k个和倒数第k+1个节点间断开 我们需要找到第k+1个节点
    // 快指针到达tail的位置后  即倒数第一个 而慢指针需要走到倒数第k+1个，所以慢指针需要比快指针慢k个节点
 
    // 先让快指针多走k步
    ListNode fast=head;
    ListNode slow=head;
    int gap=k;
    while(gap-->0){
        fast=fast.next;
    }
    // 此时前进
    while(fast!=tail){
        fast=fast.next;
        slow=slow.next;
    }
    // 先缓存slow.next,然后断开即可
    ListNode result=slow.next;
    slow.next=null;
    return result;

 }
}
```

### 6. 四数之和

> #### [四数之和](https://leetcode-cn.com/problems/4sum/)
>
> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> 0 <= a, b, c, d < n
> a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {

        if(nums==null||nums.length<4){
            return new ArrayList<>();
        }

        // 1. 先排序
        Arrays.sort(nums);

        int len=nums.length;

        List<List<Integer>> list=new ArrayList<>();

        //  四数之和就是固定两个数  然后复用三数之和的逻辑
        for(int i=0;i<len-3;i++){
            int nums1=nums[i];

            // 2.1 和三数之和一样的逻辑  跳过
            if(i-1>=0 && nums1==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<len-2;j++){ // 这里需要继续考虑怎么做
                int nums2=nums[j];
                // 2.2 一样是跳过  为啥一定要j>i+1 保证了和i保持两个数的距离？！
                if(j>i+1 && nums2==nums[j-1]){
                    continue;
                }
               
                int slow=j+1;
                int fast=len-1;
                 int twoSum=target-nums1-nums2;
                while(slow<fast){
                    if(nums[slow]+nums[fast]==twoSum){
                        list.add(Arrays.asList(nums1,nums2,nums[slow],nums[fast]));

                        // 3. 还是老样子 重复则需跳过
                        while(slow<fast && nums[slow]==nums[++slow]);
                        while(slow<fast && nums[fast]==nums[--fast]);
                    }
                    // 4. 小于则往右边移动
                    if(nums[slow]+nums[fast]<twoSum){
                        slow++;
                    }
                    // 5. 大于则往左边移动
                    if(nums[slow]+nums[fast]>twoSum){
                        fast--;
                    }
                }
            }
        }

        return list;


    }
}
```

### 7. 下一排列

> #### [下一个排列](https://leetcode-cn.com/problems/next-permutation/)
>
> 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须 原地 修改，只允许使用额外常数空间。

```java
class Solution {
    public void nextPermutation(int[] nums) {


        // 在尽可能靠右的低位进行交换，需要从后向前查找
        // 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
        // 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。
          // 以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。
          // 显然 123546 比 123564 更小，123546 就是 123465 的下一个排列


        // 也就是三步 
        // 1.从后往前找 找到一个非升序的数的位置
        // 2.交换该数与  124563的下一个是124635   交换的是5和6变成124653 再将倒数第3后面的倒数第1和倒数第二排序
        //               123465的逻辑是  交换的是4和5 先得到 123564  再后面的排序变成123546
        // 所以第二步是交换该数和第一个大于该数的数（从后往前数） 
        // 3. 排序后面的数字
        if(nums==null ){
            return;
        }
        if(nums.length<=1){
            return;
        }
        
        // 对于任意的一个排列 比如123465
        // 如何确认要交换的fast的位置呢 --fast 应该比fast的值小 此时的fast位置确定
        // 从后往前  找到第一个非升序的值的位置 确认为需要交换的第一个数
        int len=nums.length;
        int fast=len-2;
        while(fast>=0 && nums[fast]>=nums[fast+1]){
            fast--;
        }

        
        // 也就是从后往前全是升序的  即从前往后都是逆序的 此时重置为升序排列
        if(fast==-1){
            Arrays.sort(nums);
            return;
        }
        // 至此已经确认了fast的位置
        // 第2步 确认要交换的位置 slow
        int slow=len-1;
        while(slow>=0 && nums[fast]>=nums[slow]){
            slow--;
        }
        reverse(nums,slow,fast);

        // 第3步 调整fast之后的值为升序 因为调整后 后面的数的顺序是逆序（从前往后） 所以需要将后面的数reverse即可
        int p1=fast+1;
        int p2=len-1;
        while(p1<p2){
            reverse(nums,p1,p2);
            p1++;
            p2--;
        }
    }


    public void reverse(int [] nums,int p1,int p2){
        int tmp=nums[p1];
        nums[p1]=nums[p2];
        nums[p2]=tmp;
    }
}
```

## 二、（五星重要）排序

## 三、（四星重要）贪心思想

==贪心算法并没有固定的套路。==

所以唯一的难点就是==如何通过局部最优，推出整体最优。==

也==无法通过套路判断是否能从局部最优推出整体最优==

==**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。==

严格的数学证明有以下方法：

- ==数学归纳法 ：证明整体最优，这里就去好好想想高中的数列吧。==
- 反证法：证明不能用贪心

### 1. 分发饼干

> #### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211101224934167.png" alt="image-20211101224934167" style="zoom:67%;" />

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {

        // 用大饼干喂饱胃口大的
        // 为什么用大饼干喂给大的是最优  因为喂给小的会损害胃口大的权益 毕竟胃口大或者胃口小 一块饼干只能喂一个人
        // 高中的数学归纳法 可以假设用大饼干喂饱胃口大的优  
      
        if(g==null||s==null||g.length==0||s.length==0){
            return 0;
        }

        Arrays.sort(g);
        Arrays.sort(s);

        int leng=g.length;
        int lens=s.length;
        if(s[lens-1]<g[0]){
            return 0;
        }

        int res=0;
        int i=lens-1, j=leng-1;
        while(i>=0&&j>=0){
            if(s[i]>=g[j]){
                res++;
                i--;
                j--;
            }else{
                // 不满足这个小朋友可以试着去满足下一个小朋友
                // 只需要轮到下个小朋友即可 不需要i--
                j--;
            }
        }

        return res;
        

    }
}
```

### 2. 摆动数列

> #### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211102001720883.png" alt="image-20211102001720883" style="zoom:67%;" />

局部最优：==删除单调坡度上的节点（不包括单调坡度两端的节点）==，那么这个坡度就可以有两个局部峰值。

整体最优：==整个序列有最多的局部峰值，从而达到最长摆动序列。==

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(null==nums){
            return 0;
        }

        if(nums.length<=1){
            return nums.length;
        }

        int curGap=0;
        int preGap = nums[1] - nums[0];
        // 初始化res
        int res = preGap != 0 ? 2 : 1;
        // 你画画图就知道  其实是统计波峰和波谷的数量
        for(int i=2;i<nums.length;i++){
            curGap=nums[i]-nums[i-1];
            // 注意为什么一定要preGap取到0，而不能让curGap取到0
            // 因为一旦curGap等于0 res根本不会变
            if(curGap>0&&preGap<=0||curGap<0 &&preGap>=0){
                res++;
                preGap=curGap;

            }
        }
        return res;
    }
}
```

### 3. 买卖股票的最佳时机II

> #### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211103203749642.png" alt="image-20211103203749642" style="zoom:67%;" />

本题首先要清楚两点：

- ==只有一只股票！==
- 当前==只有买股票或者买股票的操作==

想获得利润==至少要两天为一个交易单元==。

那么根据prices可以得到==每天的利润序列==：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

拿到正利润之和即可

```java
// 贪心思路
class Solution {
    public int maxProfit(int[] prices) {
        int result = 0;
        for (int i = 1; i < prices.length; i++) {
            result += Math.max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
}

```

### 4. 跳跃游戏

> #### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
>
> 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211103220638255.png" alt="image-20211103220638255" style="zoom:80%;" />

```java
class Solution {
    public boolean canJump(int[] nums) {
/***********************方法一 听说要用贪心算法 ***************************** */
        // 当前位置是否能够到达  需要判断前些位置是否能够到达当前位置  
        // 所以需要实时更新当前最大能够跳到的位置
        // i+nums[i]是否能够到达
        int len=nums.length;
        if(len==1){
            return true;
        }
        if(nums[0]==0){
            return false;
        }
        // 初始化能跳到的最大位置
        int max=0;
        for(int i=0;i<len;i++){
            // 在当前位置能跳到的情况下
            if(i<=max){
                // 实时更新最大的数
                max=Integer.max(max,i+nums[i]);
                if(max>=len-1){
                    return true;
                }
            }  
        }
        return false;


/*******************方法二**************************** */    
        // // 毫无疑问的动态规划
        // // 是否能到达本目标即上一个位置能到达  且距离大于。。。
        // // 好像做过
        // // 但是前面哪个好像是最少多少步
        // // 这个是是否能跳到
        // // 这需要枚举前面的情况
        // int len=nums.length;
        // boolean [] f=new boolean[len];
        // f[0]=true;
        // for(int i=1;i<len;i++){
        //     for(int j=0;j<i;j++){
        //         if(f[j]==true && nums[j]>=i-j){
        //             f[i]=true;
        //             break;
        //         }
        //     }
        // }

        // return f[len-1];

    }
}
```

### 5. 跳跃游戏II

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。
>

```java
class Solution {
    public int jump(int[] nums) {
        // // 一定是动态规划
        // // 前一个位置一定是也是最少次数跳到的，而且该位置的值不小于该位置到最后一个位置的距离差
        // // 设f[i]为跳到第i个位置的最小跳跃次数
        // // 则f[i]=min(f[j]|a[j-1]大于跳跃距离)+1{i大于j}
        // int len=nums.length;
        // int [] f=new int[len+1];

        // f[0]=0;f[1]=0;

        // for(int i=2;i<len+1;i++){
        //     int tmp=Integer.MAX_VALUE;
        //     for(int j=1;j<i;j++){ 
        //         if(!(nums[j-1]<i-j)){
        //             tmp=tmp>f[j]?f[j]:tmp;
        //         }
        //     }
        //      // 求f[j]的最小值
        //             f[i]=tmp+1;
        // }

        // return f[len];

        // 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。
        int nextCover = 0;
        int curCover = 0;
        // 初始化为0
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            // 遍历i只是为了拿到能跳的最大距离
            nextCover = Integer.max(i + nums[i], nextCover);
            // 而只有当i到达当前的覆盖距离下标时才真正算跳了一次
            // 保证当前跳的最远
            if (i==curCover){
                // 已经到达可以到达集合终点，无需+1
                if (curCover>=nums.length-1){
                    break;
                }else{
                    // 只有当前覆盖距离不能到达 会去加一
                    res++;
                    curCover=nextCover;
                    // 验证此时是否能够到达 不用真的再去跑了
                    if (curCover>=nums.length-1){
                        break;
                    }
                }
            }
        }
        return res;
    }
}
```

### 6. 最大子序和

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107230948654.png" alt="image-20211107230948654" style="zoom: 67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107231050300.png" alt="image-20211107231050300" style="zoom: 67%;" />

### 7. 按照身高重建队列

> #### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
>
> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
>
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107231307277.png" alt="image-20211107231307277" style="zoom: 67%;" />

### 8. 无重叠区间

> #### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)
>
> 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
>
> 注意:
>
> 可以认为区间的终点总是大于它的起点。
> 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211108220457329.png" alt="image-20211108220457329" style="zoom:80%;" />

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals==null||intervals.length==0 || intervals.length==1){
            return 0;
        }

        // new Comparator<T>中的泛型是数组的元素的类型
        // 这里的二维数组的元素当然是一维数组
        // 这里的一维数组都只有两个元素，共同表示为区间
        // 注意o1-o2为顺序 o2-o1为逆序
        // 我们要的是顺序，且是按照第二个元素来比较的，即区间的结束点
        Arrays.sort(intervals, (o1, o2) -> {
            if(o1[1]==o2[1]){
                // 相等的话小区间在前比较合适
                return o1[0]-o2[0];
            }
            return o1[1]-o2[1];
        });

        int [] option=intervals[0];
        // 先求最多能留下多少个非交叉的子区间  
        // 减去这些数量的子区间就可以得到最少应该移去多少个区间
        int count=1;
        int len=intervals.length;
        for(int i=1;i<len;i++){
            if(intervals[i][0]<option[1]){
                continue;
            }
            count++;
            option=intervals[i];
        }


        return len-count;
    }
}
```

### 9. 划分字母区间

> #### [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)
>
> 字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211110231740719.png" alt="image-20211110231740719" style="zoom:67%;" />

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> res=new ArrayList<>();
        if(s==null||s.length()==0){
            return res;
        }

        int len = s.length();
        // 记录字母出现的最远位置
        Map<Character, Integer> st = new HashMap<>();
        for (int i = 0; i < len; i++) {
            st.put(s.charAt(i), i);
        }


        int currentMaxBound = 0;
        int start=0;
        for (int i = 0; i < len; i++) {
            int tmp = st.get(s.charAt(i));
            // 得到最远边界
            currentMaxBound=Math.max(tmp,currentMaxBound);
            // 当前位置是前面的所有位置的最远边界时可以拿到一个slice
            if (currentMaxBound==i){
                // 统计该段的长度即可
                res.add(currentMaxBound-start+1);
                start=currentMaxBound+1;
            }
        }

        return res;
    }
}
```

### 10.单调递增的数字

> #### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)
>
> 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
>
> （当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        if(n==0){
            return 0;
        }
        char []ns=String.valueOf(n).toCharArray();
        int len=ns.length;
        int start=Integer.MAX_VALUE;
        for(int i=len-1;i>0;i--){
            if(ns[i-1]>ns[i]){
                // 这里不是填充一个9
                // 而是填充[i,len-1]全为9
                // 所以要不断的更新start的位置
                start=i;
                ns[i-1]--;   
            }
        }

        StringBuilder res=new StringBuilder();
        for (int i=0;i<len;i++){
            if (ns[i]=='0'&&i==0)
            //防止出现09这样的情况
                continue;
            if (i>=start){
                res.append('9');
            }else {
                res.append(ns[i]);
            }
        }
        return Integer.parseInt(res.toString());

    }
}
```

## 四、（四星重要）二分查找

## 五、（四星重要）分治

## 六、搜索

### 6.1 （三星重要）BFS

### 6.2 （四星重要）DFS

先给一个模板吧

```java
void dfsCall(Graph G) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (v=0; v<G.vexnum; ++v) // 遍历这张图  可以是数组的每个点
        visited[v] = FALSE; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (v=0; v<G.vexnum; ++v)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[v]) 
            DFS(G,v); //对尚未访问的顶点调用 DFS
}


void DFS(Graph G,int v ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[v]=TRUE;  
    Visit(v); //访问第 v 个顶点  可以是输出可以是别的
	for (w=FisrtAdjVex(G,v);w>=0; w=NextAdjVex(G,v,w))  // 问题的关键是怎么定义邻居节点
        
		if (!visited[w]) DFS(G,w); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

要不先尝试一下把数组转换成图的结构  ==邻接矩阵表示法==

```java
int [] nums;
int len=nums.length;
boolean [][] rel=new boolean[len][len];

for(int i=0;i<len;i++){
    for(int j=0;j<len;j++){
        if(i==j){
            rel[i][j]=true;  // 这是自己
        }else{
            rel[i][j]=false;  // 这是邻居
        }
    }    
}
```

```java
void dfsCall(int []nums,boolean [][] rel) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[nums[i]]) 
            DFS(nums,rel,nums[i]); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,boolean [][] rel,int i ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[nums[i]]=true;  
    Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[nums[i]]) DFS(nums,rel,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

我可不可以不去定义那个图，心中有图不行吗？

```java
void dfsCall(int []nums) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,int i ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[i]=true;  
    //Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
    list.add(i);
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[i]) DFS(nums,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

现在的问题是这个==visited数组是全局的吗==？

答案：==是的==

```java
 for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
```

如果是个全连接图，那么需要循环几次？

答案：==一次==

循环次数决定于图的连接情况

```java
void dfsCall(int []nums) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,int i , visited 标记数组) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[i]=true;  
    //Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
    list.add(i);
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[i]) DFS(nums,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

## 七、(五星重要)回溯算法

#### 概念 

把问题的解空间转化成了==图或者树的结构表示==，然后使用==深度优先搜索策略进行遍历==，遍历的过程中记录和寻找所有可行解或者最优解。是通用解题方法。

其实就是==深度优先搜索==

==回溯算法是纯暴力搜索==

数独、八皇后、`0-1` 背包、图的着色、旅行商问题、全排列

状态变量：

==数组==

==当前递归深度==

==是否使用==

```java
// 模板
void backtracking(/**很多参数*/ ){
    if(终止条件){
        1. 收集结果
        2. return;
    }
    for(集合元素){
        3.处理节点
        4.递归操作
        5.回溯操作
    }
}
```

#### 组合问题

##### leetcode 77 组合

leetcode77 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
       // 结果参数 其实不必传进去
        List<List<Integer>> res = new LinkedList<>();
        // 路径参数
        LinkedList<Integer> path = new LinkedList<>();
        backtracking(n, 1, k, path, res);
        return res;
    }
    /*
    int n: n
    int pos:开始遍历的点，遍历的起
    int k:需要递归的参数
    LinkedList <Integer>path：路径
    List<List<Integer>> res：结果
    */
    private void backtracking(int n, int start, int k,
                              LinkedList<Integer> path, List<List<Integer>> res) {
        // 1. 终止条件 收集path到res中
        if (path.size() == k) {
            // 一定注意,添加的时候要去new一个 而不是直接添加  
            res.add(new LinkedList<Integer>(path));
            return;
        }
        // 一定要注意i=pos这一项   这是确保组合的关键  如果没有将与排列相似
        // for(int i=pos;i<=n;i++){
        // 这里做了剪枝操作 因为根本不需要到n了
        // k-path.size()表示还剩多少要收集
        // 所以i的最大值为n-(k-path.size())+1,画图即可知，
        // 因为n-(k-path.size())+1到n的距离为
        // [n-(n-(k-path.size())+1)]+1=k-path.size()
        for (int i = start; i <= n - (k - path.size()) + 1; i++) {
            path.addLast(i);
            // 注意这里是i+1，
            // 等于前面的不再遍历
            // 注意 注意 注意
            backtracking(n, i + 1, k, path, res);
            path.removeLast();
        }
    }
    
}
```

##### leetcode 39 组合总和（不限定只使用一次，不限定长度）

leetcode 39 给定一个==无重复元素==的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以==无限制重复被选取==。如果至少一个所选数字数量不同，则两种组合是唯一的。 

对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {

        Arrays.sort(candidates);
        // 参数一：candidates

        // 参数二：目标值


        // 参数三：起始位置

        // 参数四：总和
        int sum=0;

        // 参数五 path
        LinkedList <Integer> path=new LinkedList<>();
        // 参数六：res
        List<List<Integer>> res =new LinkedList<>();
        backtracking(candidates,target,0,0,path,res);

        return res;

    }
    
     private void backtracking(int [] nums, int target, int pos, 
                               int sum,LinkedList<Integer> path, 
                               List<List<Integer>> res ){
        if(sum==target){
            res.add(new LinkedList<Integer>(path));
            return;
        }
        if(sum>target){
            return;
        }
        // nums是有序的，需要事先进行排序
        // 注意这里的剪枝操作
        for(int i=pos;i<nums.length && sum+nums[i]<=target;i++){
            path.addLast(nums[i]);
            sum+=nums[i];
            // 注意这里还是i，不是i+1，因为这里可以重复使用
            backtracking(nums,target,i,sum,path,res);
            path.removeLast();
            sum-=nums[i];

        }  
}
```

##### leetcode 40 组合总和II（限定只能使用一次，不限定组合的长度）

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中==只能使用一次==。
>
> 注意：解集不能包含重复的组合。

```java
package com.dexlace.factory.normal;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

class Solution {
    int sum=0;
    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res =new LinkedList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        //加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] visited = new boolean[candidates.length];
        backtracking(candidates, target, 0, visited);
        return res;
    }



    // 呀好烦 参数太多了  把一些参数做成全局变量吧
    //   private void backtracking(int [] nums, int target, int start,
    //                         int sum,LinkedList<Integer> path, List<List<Integer>> res ,
    //                         boolean[] visited){

    private void backtracking(int [] nums, int target,
                              int start, boolean[] visited){
        if(sum==target){
            res.add(new LinkedList<Integer>(path));
            return;
        }
        if(sum>target){
            return;
        }
        // nums是有序的，需要事先进行排序
        // 注意这里的剪枝操作
        for(int i=start;i<nums.length && sum+nums[i]<=target ;i++){
            // 减枝要满足的是回退的情况下，比如某个数回退了，
            // 那么下一个数来代替它  需要保证回退的值和下一个替代他的值不一样
            // 需要掠过
            // 但是还有一种情况 在递归过程中的上一个和下一个相同其实不必跳过的，
            // 因为他们不属于同一个层级的  即同属于一个组合的一份子
            // 以上两种情况的区别在于
            // 前者回退时可以把该数置为未访问
            // 而在访问一个节点时，需要把该节点记作已经访问，这样递归时不属于统一层级的可以不跳过
            //出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
                continue;
            }
            visited[i]=true;
            path.addLast(nums[i]);
            sum+=nums[i];
            // 这里是i+1,因为不可以重复使用
            // 但是依旧会有可能出现重复解，如何剪枝呢
            // 要么就是用个set去重  但是很垃圾
            backtracking(nums,target,i+1,visited);
            // 这里回溯 是回溯的时候要去比较？
            // 这里做的是什么？ 把最后一个数删去继续递归
            // 应该是刚开始去剪枝吧-
            // 就像双指针一样
            path.removeLast();
            sum-=nums[i];
            visited[i]=false;
        }
    }
}
```

##### leetcode 216 组合总和III（限定使用k个数，且是非重复的）

> 找出所有相加之和为 n 的 ==k 个数的组合==。组合中==只允许含有 1 - 9 的正整数==，并且每种组合中==不存在重复的数字==。
>
> 说明：
>
> 所有数字都是正整数。
> 解集不能包含重复的组合。 

```java
class Solution {
    private LinkedList<Integer> path=new LinkedList<>();
    private List<List<Integer>> res=new LinkedList<>();
    private int sum=0;

    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracking(1, k, n);
		return res;

    }

    private void backTracking(int start,int k,int n){
        if(sum>n){
            return;
        }
        if(path.size()==k && sum==n ){
            res.add(new LinkedList<Integer>(path));
            return;
        }


        for(int i=start;i<=9-(k-path.size())+1;i++){
            sum+=i;
            path.add(i);
            backTracking(i+1,k,n);
            path.removeLast();
            sum-=i;
        }
             
    }
}
```

这题其实更简单

上面的题可以看出

1. **for循环中的是递归的宽度，是数的深度，是取值范围，是n，不是k**
2. **for的起始是递归的深度，是递归的位置，是深度在宽度中的一个组合**
3. **我这里没有去画递归图，但是最重要的其实就是递归图**

##### leetcode 17 电话号码中的组合

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
class Solution {

    // 用数组的序号对应相应的值比用map来对应简洁
    // 所以不要死脑筋
    private static final String[] KEYS = {"", "", "abc", "def", "ghi",
            "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public List<String> letterCombinations(String digits) {
        // 结果
        List<String> res = new ArrayList<>();
        if (null == digits || digits.length() == 0) {
            return res;
        }
        char[] chars = digits.toCharArray();
        // 路径参数
        StringBuffer path = new StringBuffer();
        dfs(0, chars, res, path);
        return res;
    }

    /**
     * 递归深度  注意不要把递归深度用在递归终止条件中
     * 要遍历的序列或者长度 这里是digits代表的数组 chars
     * 结果
     * 收集的路径参数
     */
    private void dfs(int depth, char[] chars, List<String> list, StringBuffer path) {
        if (path.length() == chars.length) {
            list.add(new String(path));
            return;
        }
        for (int i = depth; i < chars.length; i++) {
            char[] temp = KEYS[chars[i] - '0'].toCharArray();
            for (int j = 0; j < temp.length; j++) {
                path.append(temp[j]);
                // 应该在这里去递归
                dfs(i + 1, chars, list, path);
                // 回溯 在这里反悔了
                path.deleteCharAt(path.length() - 1);
            }

        }
    }
}

```

#### 排列问题

##### leetcode 46 全排列

leetcode46 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        permuteHelper(nums);
        return result;
    }

    private void permuteHelper(int[] nums){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            if (used[i]){
                continue;
            }
            // 标记已经被访问
            used[i] = true;
            path.add(nums[i]);
            // 这里的递归的startIndex始终不变  因为这是排列而不是组合
            // 排列有顺序，startIndex参数始终不变
            permuteHelper(nums);
            path.removeLast();
            // 回退就将刚加上去的去除 然后重新访问 
            used[i] = false;
        }
    }
}

```

##### leetcode 47 全排列II

> 给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```java
class Solution {
    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res=new LinkedList<>();
  

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean [] used=new boolean[nums.length];
        backTracking(nums,used);
        return res;


    }


    private void backTracking(int [] nums,boolean [] used){
        if(path.size()==nums.length){
            res.add(new LinkedList<Integer>(path));
            return;
        }

        for(int i=0;i<nums.length;i++){
            // 去重 这是回退后的去重 记住 和递归过程中没关系
            if(i>0&&used[i-1]==false&&nums[i]==nums[i-1]){
                continue;
            }

            // 所以就是在全排列的基础上加上了上面的去重
            // 且一定要注意 去重是要去排序的 递增子序列那题除外
            // 不过还是注意 全排列和递归启示位置没关系
            if(!used[i]){
                used[i]=true;
                path.add(nums[i]);
                backTracking(nums,used);
                path.removeLast();
                used[i]=false;
            }
            
        }

    }
}
```



##### 剑指offer 38 字符串的排列

剑指offer 38 输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```java
class Solution {
    public String[] permutation(String s) {
        // 参数五
        List <String> res=new ArrayList<>();

        // 参数二
        int len=s.length();

        // 参数一
        char [] chs=s.toCharArray();

        // 参数三
        StringBuffer sb=new StringBuffer();

        // 参数四 
        boolean [] used=new boolean[len];

        backtracking(chs,len,sb,used,res);
        // 有重复的，那么就去去重吧 没什么好讲的
        // 再加别的剪枝逻辑真的很难想
        Set <String> set=new HashSet<>();
        for(int i=0;i<res.size();i++){
            if(!set.contains(res.get(i))){
                set.add(res.get(i));
            }        
        }

        String [] ress=new String[set.size()];

        // 现在才知道set中必须用iterator访问数据
        Iterator it=set.iterator();
        int i=0;
        while(it.hasNext()){
            // 这里才知道必须强转
            ress[i]=(String)it.next();
            i++;
        }



        return ress;
    }

    private void backtracking( char [] chs,
                              int len,
                              StringBuffer sb,
                              boolean [] used,
                              List <String> res){
        if(sb.length()==len){
            res.add(new String(sb));
            return;
        }
        for(int i=0;i<chs.length;i++){
            if(used[i]){
               continue; 
            }
            used[i]=true;
            sb.append(chs[i]);
            backtracking(chs,len,sb,used,res);
            used[i]=false;
            sb=sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

[leetcode 266 回文排列]: https://leetcode-cn.com/problems/palindrome-permutation/

给定一个字符串，判断该字符串中==是否==可以通过==重新排列组合==，形成一个回文字符串。

```java
class Solution {
    public boolean canPermutePalindrome(String s) {

        // 如果一个字符串可以组成一个回文串，
        // 那么：(1) 如果它的长度为偶数，那么每个字符都必须出现偶数次；
        // (2) 如果它的长度为奇数，那么除了一个字符出现奇数次以外，其它的字符都必须出现偶数次。
        // 因此可以总结得到，如果一个字符串可以组成一个回文串，那么出现奇数次的字符的数量不能超过 1。
        int len=s.length();
        Map <Character,Integer> map=new HashMap<>();
        for(int i=0;i<len;i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),1);
            }else{
                map.put(s.charAt(i),map.get(s.charAt(i))+1);
            }
        }  
        boolean isOk=true;  

        int count=0;
        for(Character ch:map.keySet()){
            if(map.get(ch)%2!=0 ){
                count++;
                if(count!=1){
                    isOk=false;
                    break;
                }
            }
        }

        return isOk;   

 
        }





    
}
```

#### 子集问题（就是一个组合问题）

子集问题是组合问题

##### leetcode 78 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {

        // 它也是一个组合问题
        // 只是每次递归的深度不同而已
        // 从递归深度二去开始吧  不然没必要
        // 先判断一下

        // 第一个参数
        List <List<Integer>> res=new LinkedList<>();

        // 第二个参数
        int len=nums.length;

        // 第三个参数是递归深度 pos

        // 第四个参数是一个list
        List<Integer> path=new LinkedList<>();

        // 第五个参数 是nums

        res.add(path);
        // 组合一般五个参数
        for(int depth=1;depth<=len;depth++){
            backtracking(nums,depth,0,path,res);

        }

        return res;

        
    }


    private void backtracking(int [] nums,
                              int depth,
                              int pos,
                              List<Integer> path,
                              List <List<Integer>> res){
        if(path.size()==depth){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=pos;i<nums.length;i++){
            path.add(nums[i]);
            // 一定要注意这里是i+1.而不是pos+1
            backtracking(nums,depth,i+1,path,res);
            path.remove(path.size()-1);
        }
    }
}
```

##### leetcode 90 子集II

> 给你一个整数数组 nums ，其中可能**包含重复元素**，请你返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```JAVA
class Solution {

    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res=new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if(null==nums ||nums.length==0){
            return res;
        }
        // 1.先加一个空的集合再说
        res.add(path);
        // 2.最最最最为基础也是去重技巧的基础：排序
        // 今晚我竟然死在这里
        // 服了
        Arrays.sort(nums);
        // 去重必备，记住组合II中的类似技巧
        boolean [] isVisited=new boolean[nums.length];
        // 从长度1开始
        for(int i=1;i<=nums.length;i++){
            backTracking(0,nums,i,isVisited);
        }

        return res;

    }


    private void backTracking(int start,int [] nums,int targetDepth,
                            boolean [] isVisited){
        if(path.size()==targetDepth){
            res.add(new LinkedList<Integer>(path));
            return;
        }

        for(int i=start;i<nums.length;i++){
            // 还是老规矩 就是那个双指针的三数之和去重的方案
            // 且和组合总和II是一样的去重逻辑
            if(i>0 && nums[i]==nums[i-1] && isVisited[i-1]==false){
                continue;
            }
            isVisited[i]=true;
            path.add(nums[i]);
            backTracking(i+1,nums,targetDepth,isVisited);
            path.removeLast();
            isVisited[i]=false;
        }
    
    
    }
}
```

##### leetcode 491 递增子序列

> 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

这里已然不能排序，没有三数之和的去重逻辑了

```java
class Solution {

    List<List<Integer>> res=new LinkedList<>();
    List<Integer> path=new LinkedList<>();
   

    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracking(0,nums);
        return res;

    }

    private void backTracking(int start,int [] nums){
        // 1. 我们这里没有去return
        if(path.size()>1){
            res.add(new LinkedList<Integer>(path));   
        }

        // 2 .统一递归深度使用同一个set去重
        // 也就是该层级不能再用了
        // 递归到底的情况 没有去return
        // 今天我木了 真的木了 不会不会  把递归树画出来能解决所有回溯问题吗  我不知道  我困了
        Set<Integer> set=new HashSet<>();
        for(int i=start;i<nums.length;i++){
            if((!path.isEmpty()&& nums[i]<path.get(path.size() - 1))
                    ||set.contains(nums[i])){
                continue;
            }
            
            path.add(nums[i]);
            set.add(nums[i]);
            backTracking(i+1,nums);
            path.remove(path.size()-1);
     
        }

    }

}
```



#### 切割问题(也是一个组合问题)

##### leetcode 131 分割回文串

[leetcode 131 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

```java
class Solution {
    public List<List<String>> partition(String s) {

        // 参数一 s

        // 参数二 起始位置 pos
        int pos=0;

        // 参数三 List<String> path
        LinkedList <String> path=new LinkedList<>();

        // 参数四 List<List<String>> res

        List<List<String>> res=new LinkedList<>();

        int len=s.length();

        // 参数五：查询是否为回文串
        boolean [][] f=new boolean[len][len];
        for(int i=0;i<len;i++){
            f[i][i]=true;
        }

        // 对于每个数都去以他为中心点去扩散，然后去判断是否是回文串
        for(int i=0;i<len;i++){
            // 偶数扩散
            int l1=i;
            int r1=i+1;
            while(l1>=0 && r1<len && s.charAt(l1)==s.charAt(r1)){ 
                f[l1][r1]=true;
                l1--;
                r1++;
            }
            // 奇数扩散
            int l2=i-1;
            int r2=i+1;
            while(l2>=0 && r2<len && s.charAt(l2)==s.charAt(r2)){ 
                f[l2][r2]=true;
                l2--;
                r2++;
            }

        
        }

        // 初始化的时候
        backtracking(s,0,f,path,res);
        return res;



    }

    private void backtracking(String s,
                              int pos,
                              boolean [][] isPal,
                              LinkedList<String> path,
                              List<List<String>> res){
        // 分割线
        if(pos==s.length()){
            res.add(new LinkedList<String>(path));
            return;
        }
        for(int i=pos;i<s.length();i++){
            if(isPal[pos][i]){
                // 注意每次的
                path.addLast(s.substring(pos,i+1));
                backtracking(s,i+1,isPal,path,res);
                path.removeLast();

            
            }

        }
    }
}
```

##### leetcode 93 复原IP地址

> 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按 任何 顺序返回答案。
>
> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
>

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {

        List<String> res=new LinkedList<>();
        LinkedList<String> path=new LinkedList<>();
        // 这么简单的剪枝 我竟然不知道  我还去每次都判断
        if (s.length() > 12) 
            return res; 
        backtracking(0,s,path,res);
        return res;
    }


    private void backtracking(int start,String s,LinkedList<String> path,List<String> res){
        
        // 实在是没想到这一点，当长度等于3的时候去判断
        if(path.size()==3 ){
            String merged=path.stream().filter(
                string->!string.isEmpty()).collect(Collectors.joining("."));
            if(isValid(s.substring(start,s.length()))){
                res.add(merged+"."+s.substring(start,s.length()));    
            }
             
            return; 
        }

        for(int i=start;i<s.length();i++){
          
            // 判断是否合法
            String element=s.substring(start,i+1);
            // 注意 不合法是跳过 而不是返回
            if(!isValid(element)){
                //这里break continue return竟然都行
                // 其中continue是在做无用功
                // break 和return是一样的
                // [start,i+2)更不会合法
                break;
            }

            path.addLast(s.substring(start,i+1));
            backtracking(i+1,s,path,res);
            path.removeLast();


        }
    }


    // 怎么感觉在考这个  因为我这个写的不对 泥马
    private boolean isValid(String s){
        if(s==null||s.length()==0){
            return false;
        }

        if (s.charAt(0) == '0' && s.length()!=1) { // 0开头的数字不合法
            return false;
        }
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 如果⼤于255了不合法
                return false;
            }
        }
        return true;
    }
}
```

#### 棋盘问题

##### leetcode 51 N皇后

> n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
>
> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211123203935252.png" alt="image-20211123203935252" style="zoom:50%;" />

```java
class Solution {

//    void backtracking(参数) {
//     if (终止条件) {
//         存放结果;
//         return;
//     }
//     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
//         处理节点;
//         backtracking(路径，选择列表); // 递归
//         回溯，撤销处理结果
//     }
// }

    List<List<String>> res = new ArrayList<>();
    // 递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
    // 每次都是要从新的一行的起始位置开始搜，所以都是从0开始。
    // 递归终止条件 
    public List<List<String>> solveNQueens(int n) {
        // 初始化一个棋盘的默认值
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTracking(n, 0, chessboard);
        return res;

    }

    // n表示要递归的target
    // row代表需要递归的行  启示每次for循环的是每一行的列值 代表的是递归的宽度
    // 而每次递归的过程中是为了遍历不同的行，所以要代入目前递归的行的信息
    // 也就是递归的深度 与以前的startIndex一样
    // 还是不习惯 还是用startIndex吧，
    private void backTracking(int n, /*int row*/ int startIndex, char[][] chessboard){
        if(startIndex==n){
            res.add(new ArrayList<String>(array2List(chessboard)));
        }

        // 因为同一层级之间  行相同 递归的是列
        // 所以这里的是列
        for(int col=0;col<n;col++){
            if(isValid(startIndex,col,n,chessboard)){
               // 放置皇后
               chessboard[startIndex][col] = 'Q';
               backTracking(n, startIndex+1, chessboard);
               // 回退
               chessboard[startIndex][col] = '.'; 
            }
        }
    }

    // 数组转list
    public List array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        // 遍历棋盘的每一行 并添加为一个list
        for (char[] c : chessboard) {
            // 这里直接把字符数组转成string 
            list.add(String.copyValueOf(c));
        }
        return list;
    }


   
    // 作用：检测（row,col）是否合法
    // 因为在递归过程中 递归的宽度是列 
    // 行是不变的  所以要检查的是每一列
    // 而行是不变的
    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        // 检查列的时候需要去遍历之前的行在该列有没有占领
        // 有的话表示这个位置不合法
        for (int i=0; i<row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线
        // 也就是从左上角45度去遍历即可
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        // 右上角45度遍历 i-- j++ i=row-1 j=col+1
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

##### leetcode 37 数独

> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 遵循如下规则：
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }
    // 解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，
    // 相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值
    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                // (i, j) 这个位置放k是否合适
                for (char k = '1'; k <= '9'; k++){ 
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        // 如果找到合适一组立刻返回
                        // 如果找到合适一组立刻返回
                        // 如果找到合适一组立刻返回
                        if (solveSudokuHelper(board)){ 
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        // 判断任意一点(row,col)所属的九宫格  并判断之
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}

```

#### 回溯题海

##### 1. 括号生成

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> 有效括号组合需满足：左括号必须以正确的顺序闭合。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211123221255880.png" alt="image-20211123221255880" style="zoom:67%;" />

```java
class Solution {
    List<String> res = new LinkedList<>();
    public List<String> generateParenthesis(int n) {
        if (n == 0) return null;
        StringBuilder path = new StringBuilder();
        backtrack(path, n, 0, 0);
        return res;
    }
    
    void backtrack(StringBuilder path, int n, int left, int right) {
        //结束条件，左右括号相等?
        if (left == n && right == n) {
            String s = path.toString();
            res.add(s);
            return;
        }
        if (left > n || right > n)
            return;
        // 用掉的右括号大于左括号则返回
        if (right > left)
            return;
        //增加左括号
        path.append('(');
        // 1. 一直增加左括号  直到用掉的右括号大于左括号  则可以返回
        backtrack(path, n, left + 1, right);
        // 2. 一旦右括号多用了  则删除该右边括号
        path.deleteCharAt(path.length() - 1);
        // 3. 开始添加左括号
        path.append(')');
        backtrack(path, n, left, right + 1);
        path.deleteCharAt(path.length() - 1);
    }


}
```



## 七、（四星重要）动态规划

矩阵网格，只能向右或者向下走一步

题A：有多少种方式可以走到右下角  	DP

题B：输出所有到右下角的路径 		回溯

==计数、存在性、最值==适合使用dp

### 7.1 适应问题

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729164441152.png" alt="image-20210729164441152" style="zoom:67%;" />

### 7.2 坐标型动态规划

给定一个序列或网格，需要找到序列中某些子序列或网格种的某条路径(==计数、最值、存在性==)

注意：坐标型动态规划一定是以序列中==<font color=red>某个数结尾的性质</font>==作为状态变量

#### lintcode 397 最长上升连续子序列

> 给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列的长度。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）

<font color=red>某个数结尾的性质</font>

<font color=red>某个数结尾的性质</font>

<font color=red>某个数结尾的性质</font>

强调一万遍，因为单调性的问题一定是以该数为结尾最好做

```latex
f[i]=max{1,f[i-1]+1|i>0 and a[i-1]<a[i]}
// 然后求一个max f[i]就好
```

```java
public class Solution {
    /**
     * @param A: An array of Integer
     * @return: an integer
     */
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if(A==null||A.length==0){
            return 0;
        }
        // write your code here
        int len=A.length;
        // 从左到右递增
        // int [] fl=new int[len];
        // fl[0]=1;
        // 这里挑战O(1)的空间
        int res=1;
        // 遍历的指针
        int it =1;
        for(int i=1;i<len;i++){
            if(A[i-1]<A[i]){
                it++;
            }else{
                it=1;
            }
            res=res>it?res:it;
        }
        // 重新为1
        it=1;
        for(int j=len-2;j>=0;j--){
            if(A[j]>A[j+1]){
                it++;
            }else{
                it=1;
            }
            res=res>it?res:it;
        }

        return res;
    }
}
```

#### lintcode 110 最小路径和

>  给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。
>
>  你在同一时间只能向下或者向右移动一步

```java
public class Solution {
    /**
     * @param grid: a list of lists of integers
     * @return: An integer, minimizes the sum of all numbers along its path
     */
    public int minPathSum(int[][] grid) {
        // write your code here
        int m=grid.length;
        int n=grid[0].length;

        //f[i][j]=min{f[i-1][j],f[i][j-1]}+grid[i][j]
        int [][] f=new int[m][n];
        f[0][0]=grid[0][0];
    
        // 注意这里是n因为变化的是列
        for(int i=1;i<n;i++){
            f[0][i]=f[0][i-1]+grid[0][i];   
        }

        // 这里变化的是行  注意
        for(int j=1;j<m;j++){
            f[j][0]=f[j-1][0]+grid[j][0];   
        }

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                f[i][j]=Math.min(f[i-1][j],f[i][j-1])+grid[i][j];
            }
        }

        return f[m-1][n-1];

    }
}
```

#### lintcode 115 不同的路径 II

> "[不同的路径](http://www.lintcode.com/problem/unique-paths/)" 的跟进问题：
>
> 现在考虑网格中有障碍物，那样将会有多少条不同的路径？
>
> 网格中的障碍和空位置分别用 1 和 0 来表示。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729180511496.png" alt="image-20210729180511496" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729180629625.png" alt="image-20210729180629625" style="zoom:67%;" />

```java
public class Solution {
    /**
     * @param obstacleGrid: A list of lists of integers
     * @return: An integer
     */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // write your code here
        int m=obstacleGrid.length;
        int n=obstacleGrid[0].length;

        int [][] f=new int[m][n];

        // f[0][0]初始值
        if(obstacleGrid[0][0]==0){
            f[0][0]=1;
        }

        // 如果这个格子是障碍物的话
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(obstacleGrid[i][j]==1){
                    f[i][j]=0;
                }
            }
        }

        // 第一行
        for(int i=1;i<n;i++){
            if(obstacleGrid[0][i]==0){
                f[0][i]=f[0][i-1];
            }    
        }

        // 第一列
        for(int j=1;j<m;j++){
            if(obstacleGrid[j][0]==0){
                f[j][0]=f[j-1][0];
            }    
        }

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==0){
                    f[i][j]=f[i-1][j]+f[i][j-1];
                }
            }
        }
        return f[m-1][n-1];
       
    }
}
```

#### lintcode 553 炸弹袭击

> 给定一个二维矩阵, 每一个格子可能是一堵墙 `W`,或者 一个敌人 `E` 或者空 `0` (数字 '0'), 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会==杀死所有在同一行和同一列没有墙阻隔的敌人==。 由于墙比较坚固，所以墙不会被摧毁.
>
> 你只能在空的地方放置炸弹.

这个待定  比较复杂

### 7.3 序列型动态规划

更偏向于决策性问题

序列型动态规划的==每个元素的某种性质==是动态规划过程中必须考虑的

注意这里的==数组开的比原本的大1==

#### lintcode 515 房屋染色

> 这里有`n`个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得**相邻的房屋颜色不同**，并且费用最小，返回最小的费用。
>
> 费用通过一个`n`x`3` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染红色的费用，`cost[1][2]`表示房屋`1`染绿色的费用，依此类推。找到油漆所有房子的最低成本。
>
> 所有费用都是正整数

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729212949901.png" alt="image-20210729212949901" style="zoom:80%;" />

请注意==前i栋房子的概念，第i栋对应的下标为i-1==

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729213303682.png" alt="image-20210729213303682" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729214017647.png" alt="image-20210729214017647" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729214057022.png" alt="image-20210729214057022" style="zoom:67%;" />



```java
public class Solution {
    /**
     * @param costs: n x 3 cost matrix
     * @return: An integer, the minimum cost to paint all houses
     */
    public int minCost(int[][] costs) {
        // write your code here
        int n=costs.length;

        int [][] f=new int[n+1][3];
        f[0][0]=f[0][1]=f[0][2]=0;
        
       
        for(int i=1;i<n+1;i++){
            for(int j=0;j<3;j++){
                int tmp=Integer.MAX_VALUE;
                for(int k=0;k<3;k++){
                    if(k!=j){
                        tmp=tmp>f[i-1][k]?f[i-1][k]:tmp;
                    }
                }
                f[i][j]=tmp+costs[i-1][j];
            }
        }
        
        return Math.min(f[n][0],Math.min(f[n][1],f[n][2]));

    }
}
```

#### lintcode 516 房屋染色 II

> 这里有`n`个房子在一列直线上，现在我们需要给房屋染色，共有`k`种颜色。每个房屋染不同的颜色费用也不同，你希望每两个相邻的房屋颜色不同
>
> 费用通过一个`n`x`k` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染颜色`0`的费用，`cost[1][2]`表示房屋`1`染颜色`2`的费用。找到油漆所有房子的最低成本。

暂时不总结

#### lintcode 392 打劫房屋

> 假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 **当相邻的两个房子同一天被打劫时，该系统会自动报警**。
>
> 给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，**在不触动报警装置的情况下**, 你最多可以得到多少钱 。

性质就是==每间房屋到底偷还是不偷==

用`f[i][0]`表示不偷房子`i-1`的前提下，前`i`栋房子最多偷多少金币

用`f[i][1]`表示偷房子`i`的前提下，前`i`栋房子最多偷多少金币

`f[i][0]=max{f[i-1][0],f[i-1][1]}`:==因为不偷房子i-1，所以房子i-2可以选择偷或者不偷==

`f[i][1]=f[i-1][0]+A[i-1]`:==其实`f[i-1][0]`代表了`f[i-2]`的所有状态==

其实可以消去一个状态，就是说，在偷`i`的情况下，最多能偷的金币与`i-2`栋偷不偷有关

`f[i]=max{f[i-1],f[i-2]+A[i-1]}`

```java
public class Solution {
    /**
     * @param A: An array of non-negative integers
     * @return: The maximum amount of money you can rob tonight
     */
    public long houseRobber(int[] A) {
        if(null==A||A.length==0){
            return 0;
        }
        // write your code here
        int n=A.length;
        long [] f=new long[n+1];
        f[0]=0;
        f[1]=A[0];
       

        for(int i=2;i<n+1;i++){
            f[i]=Math.max(f[i-1],f[i-2]+A[i-1]);
        }

        return f[n];

    }
}
```

<img src="%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0.assets/image-20210729231644267.png" alt="image-20210729231644267" style="zoom:67%;" />

### 7.4 划分型动态规划

划分型动态规划：

> 给定==长度为N的序列或字符串==，要求==划分为若干段==
>
> 段数不限，或指定K段
>
> 每一段满足一定的性质
>
> ==划分型动态规划的数组长度是`n+1`==

#### lintcode 513 完美平方

> 描述
>
> 给一个正整数 n, 请问最少多少个完全平方数(比如1, 4, 9...)的和等于n。

状态：设`f[i]`表示i最少被划分为几个完全平方数之和

`f[i]=min{f[i-j*j]+1} (1<=j*j<=i)`

```java
public class Solution {
    /**
     * @param n: a positive integer
     * @return: An integer
     */
    public int numSquares(int n) {
        // write your code here
        int [] f=new int[n+1];
        f[0]=0;
     

        
        for (int i = 1; i <= n; ++i) {
            f[i]=Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; ++j) {
                f[i] = Math.min(f[i], f[i - j * j] + 1);
            }
        }
        
      
        return f[n];
    }
}
```

#### lintcode 108 分割回文串

> 给定字符串 `s`, 需要将它分割成一些子串, 使得每个子串都是回文串.
>
> 最少需要分割几次?
>
> *s*.*l**e**n**g**t**h*<=2000

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729235326099.png" alt="image-20210729235326099" style="zoom:50%;" />

状态：设`s`前`i`个字符`s[0,i-1]`表示最少可以划分为`f[i]`个字符串

`f[i]=min{f[j]+1|s[j,i-1]是回文串} (j=0,1,2,...,i-1)`

```java
public class Solution {
    /**
     * @param s: A string
     * @return: An integer
     */
    public int minCut(String s) {
        // write your code here
        int n=s.length();
        int [] f=new int[n+1];
        // 划分型为什么数组长度为什么一定要多一个
        // 这是因为前i个字符串对应的是标号i-1的数据
        // 就是有几个回文子串
        f[0]=0;
  
        boolean [][] isPal=isPal(s);
        for(int i=1;i<n+1;i++){
            f[i]=Integer.MAX_VALUE;
            for(int j=0;j<i;j++){
                // 如果s[j,i-1]是回文串
                if(isPal[j][i-1]){
                    f[i]=Math.min(f[i],f[j]+1);
                }
                

            }
        }

        return f[n]-1;


       

       
    }



    private boolean [][] isPal(String s){

        char [] chs=s.toCharArray();
        int n=s.length();

        boolean[][] f=new boolean[n][n];
        // 这个部分竟然忘了 我说呢
        // 不能忍
        // 不能忍
        // 不能忍
        for(int i=0;i<n;i++){
            f[i][i]=true;
        }
        for(int i=0;i<n;i++){
            int l1=i;
            int r1=i+1;
            while(l1>=0 && r1<n && chs[l1]==chs[r1]){
                f[l1][r1]=true;
                l1--;
                r1++;
            }
            int l2=i-1;
            int r2=i+1;
            while(l2>=0 && r2<n && chs[l2]==chs[r2]){
                f[l2][r2]=true;
                l2--;
                r2++;
            }
        }
        return f;
    }
}
```

<img src="%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0.assets/image-20210730100639493.png" alt="image-20210730100639493" style="zoom:67%;" />

### 7.5 博弈型动态规划

### 7.6 区间型动态规划

### 7.7 双序列型动态规划

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101122462-1630858089622.png" alt="image-20210730101122462" style="zoom: 50%;" />



#### lintcode 77 最长公共子序列

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101303067-1630858110894.png" alt="image-20210730101303067" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101330183-1630858123208.png" alt="image-20210730101330183" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101351501-1630858135716.png" alt="image-20210730101351501" style="zoom:67%;" />

设`A`的程度为`m`,`B`的长度为`n`，观察`A[m-1]`和`B[n-1]`的两个字符串是否在一个对子中

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101625713-1630858152128.png" alt="image-20210730101625713" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101707439-1630858177679.png" alt="image-20210730101707439" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101724116-1630858180567.png" alt="image-20210730101724116" style="zoom:67%;" />

==子问题==

要求`A[0...m-1]`和`B[0...n-2]`的最长公共子串，`A[0...m-2]`和`B[0...n-1]`的最长公共子串和`A[0...m-2]`和`B[0...n-2]`的最长公共子串

==而原本是要求`A[0...m-1]`和`B[0...n-1]`的最长公共子串==

<font color=red>状态</font>：设`f[i][j]`为`A`前i个字符`A[0..i-1]`和`B`前j个字符`[0..j-1]`的最长公共子串的长度

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730102444439-1630858192049.png" alt="image-20210730102444439" style="zoom:67%;" />

```java
public class Solution {
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    public int longestCommonSubsequence(String A, String B) {
        // write your code here
        int m=A.length();
        int n=B.length();

        int [][] f=new int[m+1][n+1];

        for(int i=0;i<m+1;i++){
            for(int j=0;j<n+1;j++){
                if(i==0||j==0){
                    f[i][j]=0;
                }
            }
        }

        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                f[i][j]=Math.max(f[i-1][j],f[i][j-1]);
                if(A.charAt(i-1)==B.charAt(j-1)){
                    f[i][j]=Math.max(f[i][j],f[i-1][j-1]+1);
                }
            }
        }

        return f[m][n];

    }
}
```

## 八、（三星重要）树



## 九、栈和队列

## 十、哈希表

## 十一、字符串

## 十二、数组与矩阵

## 十三、图

## 十四、位运算

