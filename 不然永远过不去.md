菜鸡算法（每日一题）

这总是绕不过去的

## 20210402

### 1.两个栈实现队列

[剑指offer 09]: https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210402203652540.png" alt="image-20210402203652540" style="zoom:80%;" />

垃圾如我，很久才对这样的输入示例看懂，实在是想死。

```java
class CQueue {

    Stack <Integer> stackIn;
    Stack <Integer> stackOut;

    public CQueue() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>();

    }
    
    public void appendTail(int value) {

        // stackIn 的栈顶就是队列的尾部
        // 如果永远不delete，或者查询，stackOut应该是永远为空
        stackIn.push(value);

    }
    
    public int deleteHead() {
        // stackOut取栈顶为队列的头部
        // 一旦要头部信息，就需要把stackIn出栈，并且存放至stackOut
        if(!stackOut.empty()){
            return stackOut.pop();
        }else{
            if(stackIn.empty())
                return -1;
            while(!stackIn.empty()){
                 stackOut.push(stackIn.pop());
            }
                return stackOut.pop();
        }       
    }
}

```

### 2. 栈中的最小元素

[包含min函数的栈]: https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/

```java
class MinStack {

    Stack <Integer> stackIn;
    
    Stack <Integer> stackOut;


    /** initialize your data structure here. */
    public MinStack() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>() ;
    }
    
    // 压栈
    // 并更新最小值
    public void push(int x) {
        stackIn.push(x);
        // 维持着从栈顶到栈底的递增
        if(stackOut.empty() || stackOut.peek() >= x)
            stackOut.push(x);

    }
    
    // 弹出最顶层元素
    // 并更新最小值
    // 弹出的元素如果是最小值,则两边都要弹出
    public void pop() {
       if((stackIn.pop()).equals(stackOut.peek()))
            stackOut.pop();
       
    }
    
    // 返回最顶层元素
    public int top() {
        return stackIn.peek();

    }
    
    public int min() {
        return stackOut.peek();
    }
}
```

## 20210718

### 说明一下图的深度优先搜索

```java
类似于树的先序遍历
    即一直深入到断点 
```

## 一、双指针

### 1. 三数之和

leetcode 15 

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

思路：双指针

如何三个数使用双指针，肯定是遍历数组，==挑出一个数，其他两个数互为相反数==，`其他两个数的遍历使用双指针`

<font color=red>在这之前</font>，要明白，双指针由于有快慢指针之分，或者方向指针之分，其中==方向指针一般适用于有序数组==

<font color=red>这里，我们就需要使用方向指针</font>,即一个left指针，一个right指针。一般是在<font color=red>有序数组</font>上使用。

所以我们`需要对数组排序`

解释以下代码的三个逻辑

1.`nums[left]+nums[right]==target`时，自然`res.add(Arrays.asList(nums[i],nums[left],nums[right]));`

且在这个逻辑下，必须跳过`++left与left对应数组值相等的情况`,同理必须跳过`--right与right对应值相等的情况`

2.在`nums[left]+nums[right]`小于`target`时左移，则`left++`，相反则`right--`

3.很容易忘记的一点是，每次`遍历的第一个数如果和前一个数相同`，应该需要`跳过该数的逻辑以以去重`

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        if(null==nums||nums.length<3){
            return res;
        }
        // 方法一  用set去重  
        // Set<List<Integer>> set=new HashSet<>();

        // 先排序  
        int len=nums.length;
        Arrays.sort(nums);

        // 双指针
        for(int i=0;i<len;i++){
            // 另外的原因  那就是遍历的数与上一个相同
            if(i>0 && nums[i]==nums[i-1]) continue;
            int target=0-nums[i];
            int left=i+1;
            int right=len-1;
            while(right>left){
                if(nums[left]+nums[right]==target){

                    // // set直接去重
                    // set.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    // // 找到了第一个还有别的可能
                    // // 这里是left 和right都变
                    // left++;
                    // right--;

                    // 方法二 跳过去重
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right &&nums[left]==nums[++left]);
                    while(left<right &&nums[right]==nums[--right]);

                }
                if(nums[left]+nums[right]<target){
                    left++;

                }
                if(nums[left]+nums[right]>target){
                    right--;
                    
                }

            }
        }

        // res=new ArrayList<>(set);
        return res;

    }
}
```

### 2. 最接近的三数之和

leetcode16

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/3sum-closest
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

思路：双指针

复用三数之和的逻辑，加上一个==**记录比target大最小正gap和一个比target小的最大负gap**==，即可

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {

        // 排个序是必要的
        Arrays.sort(nums);
        int len=nums.length;
        // 双指针不回头的
               // 问题一 ：可以得到最小的gap，但是最小的gap，结果是比他大还是比他小呢
                // 问题二： 如何去重
        // 问题一：各自记录一个比target小的最大的负数值
        // 和一个比target大的最小的正数值
        int negativeGap=Integer.MIN_VALUE;
        int positiveGap=Integer.MAX_VALUE;
        for(int i=0;i<len;i++){
            // 先记录每次的出发点
            int tmp=nums[i];
            // 问题二：去重方案点一
            if(i>0 && nums[i]==nums[i-1]) continue;
            int left=i+1;
            int right=len-1;
            while(left<right){
                int sum=tmp+nums[left]+nums[right];
                if(sum==target){
                    return target;
                }else{
                    if(sum-target<0){
                        // 说明左边的值太小了
                        // 小的取最大值
                        negativeGap=negativeGap<sum-target?sum-target:negativeGap;
                        // 问题二：去重方案点二
                        while(left<right &&nums[left]==nums[++left]);
                    }else{
                        // 大的取最小值
                        positiveGap=positiveGap>sum-target?sum-target:positiveGap;
                        // 问题二：去重方案点二
                        while(left<right &&nums[right]==nums[--right]);
                        
                    }
                }
            }   
        }
        return negativeGap+positiveGap>0?target+negativeGap:target+positiveGap;
    }
}
```

### 3. 盛最多水的容器

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 说明：你不能倾斜容器。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/container-with-most-water
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211026002958419.png" alt="image-20211026002958419" style="zoom:67%;" />

```java
class Solution {
    public int maxArea(int[] height) {
        //我们移动 数字较小的那个指针
        int len=height.length;
        int left=0;
        int right=len-1;
        int area=0;
        while(left!=right){


            int tmp=(right-left)*Math.min(height[left],height[right]);
            area=Math.max(area,tmp);
            // 总之，移动数字比较小的指针，因为是他在高度方面存在短板，所以要移动
            // 左边的就向右边找
            // 右边的就向左边找
            // 仅此而已
            // mark 2021-10-26
            if(height[left]<height[right]){
                left++;
            }else{
                right--;
            }

        }
        return area;


    }
}
```

### 4. 删除倒数第n个节点

> leetcode-19
>
> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    
    public ListNode removeNthFromEnd(ListNode head, int n) {

        // 快慢指针
        
        // 注意 我们是要找倒数第n个数的前驱  也就是倒数第n+1个节点
        // 快指针为tail的next时，如果快指针比慢指针快n个节点，那么慢指针刚好处于倒数第n个节点
        // 我们想要的是前驱  所以慢指针最好到达倒数第n+1个节点，也就是快指针比慢指针快n+1

        // 所以快指针要先走n+1步
     

        

        // 已经走了一步
        ListNode fast=head;
      
        // 1.初始化 给快指针加速了n步 一共走了n+1步
        while(n>0){
            fast=fast.next;
            n--;
        }

        // 2.如果快指针为空，说明刚好有n个点 则删除头节点  返回头节点的next即可
        if(fast==null) {
            return head.next;
        }

        // 3.让快指针继续走到tail的next，记录步数
        int count=0;
        while(fast!=null){
            fast=fast.next;
            count++;
        }

        // 4. slow先初始化走了一步
        ListNode slow=head;
        count--;
        while(count>0){
            slow=slow.next;
            count--;
        }

        // 5. 此时slow到达倒数第n+1个点处，即前驱,要删除的点的前驱
        ListNode pre=slow;
        ListNode nNode=slow.next;
        ListNode n1Node=slow.next.next;
        pre.next=n1Node;

        // 返回head
        return head;


     
    }
}
```

### 5. 旋转链表的k个节点

> #### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)
>
> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
    if(head==null){
        return null;
    }

    // 1. 计算链表长度 和获取尾部节点
    ListNode tmp=head;
    ListNode tail=null; 
    int len=0;
    while(tmp!=null){
        len++;
        tail=tmp;
        tmp=tmp.next;
    }

    // 2.如果k是长度的整数倍将直接返回即可
    if(k%len==0){
        return head;
    }

    // 3 这里可以大胆的把tail和head连起来,成环了，以后的工作只需要断开即可
    tail.next=head;

    // 4. 假如k大于len 且不是整数倍 比如len=3 k=5
    // 312 231 123 312 231
    // 头部节点落在len-k%len+1
    // 需要找到头部节点的前驱 即len-k%len pre
       // 先res=pre.next
       // pre.next=null;
       // 把tail和head连上即可
       //  return res
    if(k>len){
        int prePosition=len-k%len;
        ListNode pre=head;
        prePosition--;
        while(prePosition>0){
            pre=pre.next;
            prePosition--;
        }
        // 这里已经得到了pre
        ListNode res=pre.next;
        pre.next=null;
        return res;
    }


    // 5.假如k小于len，那么将需要在倒数第k个和倒数第k+1个节点间断开 我们需要找到第k+1个节点
    // 快指针到达tail的位置后  即倒数第一个 而慢指针需要走到倒数第k+1个，所以慢指针需要比快指针慢k个节点
 
    // 先让快指针多走k步
    ListNode fast=head;
    ListNode slow=head;
    int gap=k;
    while(gap-->0){
        fast=fast.next;
    }
    // 此时前进
    while(fast!=tail){
        fast=fast.next;
        slow=slow.next;
    }
    // 先缓存slow.next,然后断开即可
    ListNode result=slow.next;
    slow.next=null;
    return result;

 }
}
```

### 6. 四数之和

> #### [四数之和](https://leetcode-cn.com/problems/4sum/)
>
> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> 0 <= a, b, c, d < n
> a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {

        if(nums==null||nums.length<4){
            return new ArrayList<>();
        }

        // 1. 先排序
        Arrays.sort(nums);

        int len=nums.length;

        List<List<Integer>> list=new ArrayList<>();

        //  四数之和就是固定两个数  然后复用三数之和的逻辑
        for(int i=0;i<len-3;i++){
            int nums1=nums[i];

            // 2.1 和三数之和一样的逻辑  跳过
            if(i-1>=0 && nums1==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<len-2;j++){ // 这里需要继续考虑怎么做
                int nums2=nums[j];
                // 2.2 一样是跳过  为啥一定要j>i+1 保证了和i保持两个数的距离？！
                if(j>i+1 && nums2==nums[j-1]){
                    continue;
                }
               
                int slow=j+1;
                int fast=len-1;
                 int twoSum=target-nums1-nums2;
                while(slow<fast){
                    if(nums[slow]+nums[fast]==twoSum){
                        list.add(Arrays.asList(nums1,nums2,nums[slow],nums[fast]));

                        // 3. 还是老样子 重复则需跳过
                        while(slow<fast && nums[slow]==nums[++slow]);
                        while(slow<fast && nums[fast]==nums[--fast]);
                    }
                    // 4. 小于则往右边移动
                    if(nums[slow]+nums[fast]<twoSum){
                        slow++;
                    }
                    // 5. 大于则往左边移动
                    if(nums[slow]+nums[fast]>twoSum){
                        fast--;
                    }
                }
            }
        }

        return list;


    }
}
```

### 7. 下一排列

> #### [下一个排列](https://leetcode-cn.com/problems/next-permutation/)
>
> 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须 原地 修改，只允许使用额外常数空间。

```java
class Solution {
    public void nextPermutation(int[] nums) {


        // 在尽可能靠右的低位进行交换，需要从后向前查找
        // 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
        // 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。
          // 以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。
          // 显然 123546 比 123564 更小，123546 就是 123465 的下一个排列


        // 也就是三步 
        // 1.从后往前找 找到一个非升序的数的位置
        // 2.交换该数与  124563的下一个是124635   交换的是5和6变成124653 再将倒数第3后面的倒数第1和倒数第二排序
        //               123465的逻辑是  交换的是4和5 先得到 123564  再后面的排序变成123546
        // 所以第二步是交换该数和第一个大于该数的数（从后往前数） 
        // 3. 排序后面的数字
        if(nums==null ){
            return;
        }
        if(nums.length<=1){
            return;
        }
        
        // 对于任意的一个排列 比如123465
        // 如何确认要交换的fast的位置呢 --fast 应该比fast的值小 此时的fast位置确定
        // 从后往前  找到第一个非升序的值的位置 确认为需要交换的第一个数
        int len=nums.length;
        int fast=len-2;
        while(fast>=0 && nums[fast]>=nums[fast+1]){
            fast--;
        }

        
        // 也就是从后往前全是升序的  即从前往后都是逆序的 此时重置为升序排列
        if(fast==-1){
            Arrays.sort(nums);
            return;
        }
        // 至此已经确认了fast的位置
        // 第2步 确认要交换的位置 slow
        int slow=len-1;
        while(slow>=0 && nums[fast]>=nums[slow]){
            slow--;
        }
        reverse(nums,slow,fast);

        // 第3步 调整fast之后的值为升序 因为调整后 后面的数的顺序是逆序（从前往后） 所以需要将后面的数reverse即可
        int p1=fast+1;
        int p2=len-1;
        while(p1<p2){
            reverse(nums,p1,p2);
            p1++;
            p2--;
        }
    }


    public void reverse(int [] nums,int p1,int p2){
        int tmp=nums[p1];
        nums[p1]=nums[p2];
        nums[p2]=tmp;
    }
}
```

## 二、（五星重要）排序

## 三、（四星重要）贪心思想

==贪心算法并没有固定的套路。==

所以唯一的难点就是==如何通过局部最优，推出整体最优。==

也==无法通过套路判断是否能从局部最优推出整体最优==

==**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。==

严格的数学证明有以下方法：

- ==数学归纳法 ：证明整体最优，这里就去好好想想高中的数列吧。==
- 反证法：证明不能用贪心

### 1. 分发饼干

> #### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211101224934167.png" alt="image-20211101224934167" style="zoom:67%;" />

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {

        // 用大饼干喂饱胃口大的
        // 为什么用大饼干喂给大的是最优  因为喂给小的会损害胃口大的权益 毕竟胃口大或者胃口小 一块饼干只能喂一个人
        // 高中的数学归纳法 可以假设用大饼干喂饱胃口大的优  
      
        if(g==null||s==null||g.length==0||s.length==0){
            return 0;
        }

        Arrays.sort(g);
        Arrays.sort(s);

        int leng=g.length;
        int lens=s.length;
        if(s[lens-1]<g[0]){
            return 0;
        }

        int res=0;
        int i=lens-1, j=leng-1;
        while(i>=0&&j>=0){
            if(s[i]>=g[j]){
                res++;
                i--;
                j--;
            }else{
                // 不满足这个小朋友可以试着去满足下一个小朋友
                // 只需要轮到下个小朋友即可 不需要i--
                j--;
            }
        }

        return res;
        

    }
}
```

### 2. 摆动数列

> #### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211102001720883.png" alt="image-20211102001720883" style="zoom:67%;" />

局部最优：==删除单调坡度上的节点（不包括单调坡度两端的节点）==，那么这个坡度就可以有两个局部峰值。

整体最优：==整个序列有最多的局部峰值，从而达到最长摆动序列。==

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(null==nums){
            return 0;
        }

        if(nums.length<=1){
            return nums.length;
        }

        int curGap=0;
        int preGap = nums[1] - nums[0];
        // 初始化res
        int res = preGap != 0 ? 2 : 1;
        // 你画画图就知道  其实是统计波峰和波谷的数量
        for(int i=2;i<nums.length;i++){
            curGap=nums[i]-nums[i-1];
            // 注意为什么一定要preGap取到0，而不能让curGap取到0
            // 因为一旦curGap等于0 res根本不会变
            if(curGap>0&&preGap<=0||curGap<0 &&preGap>=0){
                res++;
                preGap=curGap;

            }
        }
        return res;
    }
}
```

### 3. 买卖股票的最佳时机II

> #### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
>
> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211103203749642.png" alt="image-20211103203749642" style="zoom:67%;" />

本题首先要清楚两点：

- ==只有一只股票！==
- 当前==只有买股票或者买股票的操作==

想获得利润==至少要两天为一个交易单元==。

那么根据prices可以得到==每天的利润序列==：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

拿到正利润之和即可

```java
// 贪心思路
class Solution {
    public int maxProfit(int[] prices) {
        int result = 0;
        for (int i = 1; i < prices.length; i++) {
            result += Math.max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
}

```

### 4. 跳跃游戏

> #### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
>
> 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211103220638255.png" alt="image-20211103220638255" style="zoom:80%;" />

```java
class Solution {
    public boolean canJump(int[] nums) {
/***********************方法一 听说要用贪心算法 ***************************** */
        // 当前位置是否能够到达  需要判断前些位置是否能够到达当前位置  
        // 所以需要实时更新当前最大能够跳到的位置
        // i+nums[i]是否能够到达
        int len=nums.length;
        if(len==1){
            return true;
        }
        if(nums[0]==0){
            return false;
        }
        // 初始化能跳到的最大位置
        int max=0;
        for(int i=0;i<len;i++){
            // 在当前位置能跳到的情况下
            if(i<=max){
                // 实时更新最大的数
                max=Integer.max(max,i+nums[i]);
                if(max>=len-1){
                    return true;
                }
            }  
        }
        return false;


/*******************方法二**************************** */    
        // // 毫无疑问的动态规划
        // // 是否能到达本目标即上一个位置能到达  且距离大于。。。
        // // 好像做过
        // // 但是前面哪个好像是最少多少步
        // // 这个是是否能跳到
        // // 这需要枚举前面的情况
        // int len=nums.length;
        // boolean [] f=new boolean[len];
        // f[0]=true;
        // for(int i=1;i<len;i++){
        //     for(int j=0;j<i;j++){
        //         if(f[j]==true && nums[j]>=i-j){
        //             f[i]=true;
        //             break;
        //         }
        //     }
        // }

        // return f[len-1];

    }
}
```

### 5. 跳跃游戏II

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。
>

```java
class Solution {
    public int jump(int[] nums) {
        // // 一定是动态规划
        // // 前一个位置一定是也是最少次数跳到的，而且该位置的值不小于该位置到最后一个位置的距离差
        // // 设f[i]为跳到第i个位置的最小跳跃次数
        // // 则f[i]=min(f[j]|a[j-1]大于跳跃距离)+1{i大于j}
        // int len=nums.length;
        // int [] f=new int[len+1];

        // f[0]=0;f[1]=0;

        // for(int i=2;i<len+1;i++){
        //     int tmp=Integer.MAX_VALUE;
        //     for(int j=1;j<i;j++){ 
        //         if(!(nums[j-1]<i-j)){
        //             tmp=tmp>f[j]?f[j]:tmp;
        //         }
        //     }
        //      // 求f[j]的最小值
        //             f[i]=tmp+1;
        // }

        // return f[len];

        // 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。
        int nextCover = 0;
        int curCover = 0;
        // 初始化为0
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            // 遍历i只是为了拿到能跳的最大距离
            nextCover = Integer.max(i + nums[i], nextCover);
            // 而只有当i到达当前的覆盖距离下标时才真正算跳了一次
            // 保证当前跳的最远
            if (i==curCover){
                // 已经到达可以到达集合终点，无需+1
                if (curCover>=nums.length-1){
                    break;
                }else{
                    // 只有当前覆盖距离不能到达 会去加一
                    res++;
                    curCover=nextCover;
                    // 验证此时是否能够到达 不用真的再去跑了
                    if (curCover>=nums.length-1){
                        break;
                    }
                }
            }
        }
        return res;
    }
}
```

### 6. 最大子序和

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107230948654.png" alt="image-20211107230948654" style="zoom: 67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107231050300.png" alt="image-20211107231050300" style="zoom: 67%;" />

### 7. 按照身高重建队列

> #### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
>
> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
>
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211107231307277.png" alt="image-20211107231307277" style="zoom: 67%;" />

### 8. 无重叠区间

> #### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)
>
> 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
>
> 注意:
>
> 可以认为区间的终点总是大于它的起点。
> 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211108220457329.png" alt="image-20211108220457329" style="zoom:80%;" />

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals==null||intervals.length==0 || intervals.length==1){
            return 0;
        }

        // new Comparator<T>中的泛型是数组的元素的类型
        // 这里的二维数组的元素当然是一维数组
        // 这里的一维数组都只有两个元素，共同表示为区间
        // 注意o1-o2为顺序 o2-o1为逆序
        // 我们要的是顺序，且是按照第二个元素来比较的，即区间的结束点
        Arrays.sort(intervals, (o1, o2) -> {
            if(o1[1]==o2[1]){
                // 相等的话小区间在前比较合适
                return o1[0]-o2[0];
            }
            return o1[1]-o2[1];
        });

        int [] option=intervals[0];
        // 先求最多能留下多少个非交叉的子区间  
        // 减去这些数量的子区间就可以得到最少应该移去多少个区间
        int count=1;
        int len=intervals.length;
        for(int i=1;i<len;i++){
            if(intervals[i][0]<option[1]){
                continue;
            }
            count++;
            option=intervals[i];
        }


        return len-count;
    }
}
```

### 9. 划分字母区间

> #### [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)
>
> 字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211110231740719.png" alt="image-20211110231740719" style="zoom:67%;" />

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> res=new ArrayList<>();
        if(s==null||s.length()==0){
            return res;
        }

        int len = s.length();
        // 记录字母出现的最远位置
        Map<Character, Integer> st = new HashMap<>();
        for (int i = 0; i < len; i++) {
            st.put(s.charAt(i), i);
        }


        int currentMaxBound = 0;
        int start=0;
        for (int i = 0; i < len; i++) {
            int tmp = st.get(s.charAt(i));
            // 得到最远边界
            currentMaxBound=Math.max(tmp,currentMaxBound);
            // 当前位置是前面的所有位置的最远边界时可以拿到一个slice
            if (currentMaxBound==i){
                // 统计该段的长度即可
                res.add(currentMaxBound-start+1);
                start=currentMaxBound+1;
            }
        }

        return res;
    }
}
```

### 10.单调递增的数字

> #### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)
>
> 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
>
> （当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        if(n==0){
            return 0;
        }
        char []ns=String.valueOf(n).toCharArray();
        int len=ns.length;
        int start=Integer.MAX_VALUE;
        for(int i=len-1;i>0;i--){
            if(ns[i-1]>ns[i]){
                // 这里不是填充一个9
                // 而是填充[i,len-1]全为9
                // 所以要不断的更新start的位置
                start=i;
                ns[i-1]--;   
            }
        }

        StringBuilder res=new StringBuilder();
        for (int i=0;i<len;i++){
            if (ns[i]=='0'&&i==0)
            //防止出现09这样的情况
                continue;
            if (i>=start){
                res.append('9');
            }else {
                res.append(ns[i]);
            }
        }
        return Integer.parseInt(res.toString());

    }
}
```

## 四、（四星重要）二分查找

## 五、（四星重要）分治

## 六、搜索

### 6.1 （三星重要）BFS

### 6.2 （四星重要）DFS

先给一个模板吧

```java
void dfsCall(Graph G) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (v=0; v<G.vexnum; ++v) // 遍历这张图  可以是数组的每个点
        visited[v] = FALSE; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (v=0; v<G.vexnum; ++v)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[v]) 
            DFS(G,v); //对尚未访问的顶点调用 DFS
}


void DFS(Graph G,int v ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[v]=TRUE;  
    Visit(v); //访问第 v 个顶点  可以是输出可以是别的
	for (w=FisrtAdjVex(G,v);w>=0; w=NextAdjVex(G,v,w))  // 问题的关键是怎么定义邻居节点
        
		if (!visited[w]) DFS(G,w); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

要不先尝试一下把数组转换成图的结构  ==邻接矩阵表示法==

```java
int [] nums;
int len=nums.length;
boolean [][] rel=new boolean[len][len];

for(int i=0;i<len;i++){
    for(int j=0;j<len;j++){
        if(i==j){
            rel[i][j]=true;  // 这是自己
        }else{
            rel[i][j]=false;  // 这是邻居
        }
    }    
}
```

```java
void dfsCall(int []nums,boolean [][] rel) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[nums[i]]) 
            DFS(nums,rel,nums[i]); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,boolean [][] rel,int i ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[nums[i]]=true;  
    Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[nums[i]]) DFS(nums,rel,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

我可不可以不去定义那个图，心中有图不行吗？

```java
void dfsCall(int []nums) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,int i ) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[i]=true;  
    //Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
    list.add(i);
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[i]) DFS(nums,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

现在的问题是这个==visited数组是全局的吗==？

答案：==是的==

```java
 for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
```

如果是个全连接图，那么需要循环几次？

答案：==一次==

循环次数决定于图的连接情况

```java
void dfsCall(int []nums) {// 这张图可以是抽象的  你可以想象成各个点都可以互联  你要弄清节点的概念
    for (int i=0; i<nums.length; i++) // 遍历这张图  可以是数组的每个点
        visited[nums[i]] = false; //   这是初始化  但是有时后没必要  一般我们去找他的邻居去dfs了
    						// 上一步的意思是 你此时就可以把这个节点添加进一个访问列表了  不要什么初始化
       // 即得到某个节点  要去找他的邻居去深入
    //  上面是废话   注意一定  最好是去初始化是否访问  刚开始一定是没访问的，还是初始化下  
    // 因为模板总没错
    
    for (int i=0; i<nums.length; i++)    //  在数组中就是纯粹的遍历
                                  
        if (!visited[i]) 
            DFS(nums,i); //对尚未访问的顶点调用 DFS
}


void DFS(int []nums,int i , visited 标记数组) { //从第 v 个顶点出发递归地深度优先遍历图 G 
	visited[i]=true;  
    //Visit(nums[i]); //访问第 v 个顶点  可以是输出可以是别的  比如可以是去把他输入到一个list中去
    list.add(i);
	for (int j=0;j!=i&&j<nums.length; j++)  // 问题的关键是怎么定义邻居节点
        
		if (!visited[i]) DFS(nums,i); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS 
}
```

## 七、(五星重要)回溯算法

#### 概念 

把问题的解空间转化成了==图或者树的结构表示==，然后使用==深度优先搜索策略进行遍历==，遍历的过程中记录和寻找所有可行解或者最优解。是通用解题方法。

其实就是==深度优先搜索==

==回溯算法是纯暴力搜索==

数独、八皇后、`0-1` 背包、图的着色、旅行商问题、全排列

状态变量：

==数组==

==当前递归深度==

==是否使用==

```java
// 模板
void backtracking(/**很多参数*/ ){
    if(终止条件){
        1. 收集结果
        2. return;
    }
    for(集合元素){
        3.处理节点
        4.递归操作
        5.回溯操作
    }
}
```

#### 组合问题

##### leetcode 77 组合

leetcode77 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
       // 结果参数 其实不必传进去
        List<List<Integer>> res = new LinkedList<>();
        // 路径参数
        LinkedList<Integer> path = new LinkedList<>();
        backtracking(n, 1, k, path, res);
        return res;
    }
    /*
    int n: n
    int pos:开始遍历的点，遍历的起
    int k:需要递归的参数
    LinkedList <Integer>path：路径
    List<List<Integer>> res：结果
    */
    private void backtracking(int n, int start, int k,
                              LinkedList<Integer> path, List<List<Integer>> res) {
        // 1. 终止条件 收集path到res中
        if (path.size() == k) {
            // 一定注意,添加的时候要去new一个 而不是直接添加  
            res.add(new LinkedList<Integer>(path));
            return;
        }
        // 一定要注意i=pos这一项   这是确保组合的关键  如果没有将与排列相似
        // for(int i=pos;i<=n;i++){
        // 这里做了剪枝操作 因为根本不需要到n了
        // k-path.size()表示还剩多少要收集
        // 所以i的最大值为n-(k-path.size())+1,画图即可知，
        // 因为n-(k-path.size())+1到n的距离为
        // [n-(n-(k-path.size())+1)]+1=k-path.size()
        for (int i = start; i <= n - (k - path.size()) + 1; i++) {
            path.addLast(i);
            // 注意这里是i+1，
            // 等于前面的不再遍历
            // 注意 注意 注意
            backtracking(n, i + 1, k, path, res);
            path.removeLast();
        }
    }
    
}
```

##### leetcode 39 组合总和（不限定只使用一次，不限定长度）

leetcode 39 给定一个==无重复元素==的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以==无限制重复被选取==。如果至少一个所选数字数量不同，则两种组合是唯一的。 

对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {

        Arrays.sort(candidates);
        // 参数一：candidates

        // 参数二：目标值


        // 参数三：起始位置

        // 参数四：总和
        int sum=0;

        // 参数五 path
        LinkedList <Integer> path=new LinkedList<>();
        // 参数六：res
        List<List<Integer>> res =new LinkedList<>();
        backtracking(candidates,target,0,0,path,res);

        return res;

    }
    
     private void backtracking(int [] nums, int target, int pos, 
                               int sum,LinkedList<Integer> path, 
                               List<List<Integer>> res ){
        if(sum==target){
            res.add(new LinkedList<Integer>(path));
            return;
        }
        if(sum>target){
            return;
        }
        // nums是有序的，需要事先进行排序
        // 注意这里的剪枝操作
        for(int i=pos;i<nums.length && sum+nums[i]<=target;i++){
            path.addLast(nums[i]);
            sum+=nums[i];
            // 注意这里还是i，不是i+1，因为这里可以重复使用
            backtracking(nums,target,i,sum,path,res);
            path.removeLast();
            sum-=nums[i];

        }  
}
```

##### leetcode 40 组合总和II（限定只能使用一次，不限定组合的长度）

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中==只能使用一次==。
>
> 注意：解集不能包含重复的组合。

```java
package com.dexlace.factory.normal;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

class Solution {
    int sum=0;
    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res =new LinkedList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        //加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] visited = new boolean[candidates.length];
        backtracking(candidates, target, 0, visited);
        return res;
    }



    // 呀好烦 参数太多了  把一些参数做成全局变量吧
    //   private void backtracking(int [] nums, int target, int start,
    //                         int sum,LinkedList<Integer> path, List<List<Integer>> res ,
    //                         boolean[] visited){

    private void backtracking(int [] nums, int target,
                              int start, boolean[] visited){
        if(sum==target){
            res.add(new LinkedList<Integer>(path));
            return;
        }
        if(sum>target){
            return;
        }
        // nums是有序的，需要事先进行排序
        // 注意这里的剪枝操作
        for(int i=start;i<nums.length && sum+nums[i]<=target ;i++){
            // 减枝要满足的是回退的情况下，比如某个数回退了，
            // 那么下一个数来代替它  需要保证回退的值和下一个替代他的值不一样
            // 需要掠过
            // 但是还有一种情况 在递归过程中的上一个和下一个相同其实不必跳过的，
            // 因为他们不属于同一个层级的  即同属于一个组合的一份子
            // 以上两种情况的区别在于
            // 前者回退时可以把该数置为未访问
            // 而在访问一个节点时，需要把该节点记作已经访问，这样递归时不属于统一层级的可以不跳过
            //出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
                continue;
            }
            visited[i]=true;
            path.addLast(nums[i]);
            sum+=nums[i];
            // 这里是i+1,因为不可以重复使用
            // 但是依旧会有可能出现重复解，如何剪枝呢
            // 要么就是用个set去重  但是很垃圾
            backtracking(nums,target,i+1,visited);
            // 这里回溯 是回溯的时候要去比较？
            // 这里做的是什么？ 把最后一个数删去继续递归
            // 应该是刚开始去剪枝吧-
            // 就像双指针一样
            path.removeLast();
            sum-=nums[i];
            visited[i]=false;
        }
    }
}
```

##### leetcode 216 组合总和III（限定使用k个数，且是非重复的）

> 找出所有相加之和为 n 的 ==k 个数的组合==。组合中==只允许含有 1 - 9 的正整数==，并且每种组合中==不存在重复的数字==。
>
> 说明：
>
> 所有数字都是正整数。
> 解集不能包含重复的组合。 

```java
class Solution {
    private LinkedList<Integer> path=new LinkedList<>();
    private List<List<Integer>> res=new LinkedList<>();
    private int sum=0;

    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracking(1, k, n);
		return res;

    }

    private void backTracking(int start,int k,int n){
        if(sum>n){
            return;
        }
        if(path.size()==k && sum==n ){
            res.add(new LinkedList<Integer>(path));
            return;
        }


        for(int i=start;i<=9-(k-path.size())+1;i++){
            sum+=i;
            path.add(i);
            backTracking(i+1,k,n);
            path.removeLast();
            sum-=i;
        }
             
    }
}
```

这题其实更简单

上面的题可以看出

1. **for循环中的是递归的宽度，是数的深度，是取值范围，是n，不是k**
2. **for的起始是递归的深度，是递归的位置，是深度在宽度中的一个组合**
3. **我这里没有去画递归图，但是最重要的其实就是递归图**

##### leetcode 17 电话号码中的组合

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
class Solution {

    // 用数组的序号对应相应的值比用map来对应简洁
    // 所以不要死脑筋
    private static final String[] KEYS = {"", "", "abc", "def", "ghi",
            "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public List<String> letterCombinations(String digits) {
        // 结果
        List<String> res = new ArrayList<>();
        if (null == digits || digits.length() == 0) {
            return res;
        }
        char[] chars = digits.toCharArray();
        // 路径参数
        StringBuffer path = new StringBuffer();
        dfs(0, chars, res, path);
        return res;
    }

    /**
     * 递归深度  注意不要把递归深度用在递归终止条件中
     * 要遍历的序列或者长度 这里是digits代表的数组 chars
     * 结果
     * 收集的路径参数
     */
    private void dfs(int depth, char[] chars, List<String> list, StringBuffer path) {
        if (path.length() == chars.length) {
            list.add(new String(path));
            return;
        }
        for (int i = depth; i < chars.length; i++) {
            char[] temp = KEYS[chars[i] - '0'].toCharArray();
            for (int j = 0; j < temp.length; j++) {
                path.append(temp[j]);
                // 应该在这里去递归
                dfs(i + 1, chars, list, path);
                // 回溯 在这里反悔了
                path.deleteCharAt(path.length() - 1);
            }

        }
    }
}

```

#### 排列问题

##### leetcode 46 全排列

leetcode46 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        permuteHelper(nums);
        return result;
    }

    private void permuteHelper(int[] nums){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            if (used[i]){
                continue;
            }
            // 标记已经被访问
            used[i] = true;
            path.add(nums[i]);
            // 这里的递归的startIndex始终不变  因为这是排列而不是组合
            // 排列有顺序，startIndex参数始终不变
            permuteHelper(nums);
            path.removeLast();
            // 回退就将刚加上去的去除 然后重新访问 
            used[i] = false;
        }
    }
}

```

##### leetcode 47 全排列II

> 给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```java
class Solution {
    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res=new LinkedList<>();
  

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean [] used=new boolean[nums.length];
        backTracking(nums,used);
        return res;


    }


    private void backTracking(int [] nums,boolean [] used){
        if(path.size()==nums.length){
            res.add(new LinkedList<Integer>(path));
            return;
        }

        for(int i=0;i<nums.length;i++){
            // 去重 这是回退后的去重 记住 和递归过程中没关系
            if(i>0&&used[i-1]==false&&nums[i]==nums[i-1]){
                continue;
            }

            // 所以就是在全排列的基础上加上了上面的去重
            // 且一定要注意 去重是要去排序的 递增子序列那题除外
            // 不过还是注意 全排列和递归启示位置没关系
            if(!used[i]){
                used[i]=true;
                path.add(nums[i]);
                backTracking(nums,used);
                path.removeLast();
                used[i]=false;
            }
            
        }

    }
}
```



##### 剑指offer 38 字符串的排列

剑指offer 38 输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```java
class Solution {
    public String[] permutation(String s) {
        // 参数五
        List <String> res=new ArrayList<>();

        // 参数二
        int len=s.length();

        // 参数一
        char [] chs=s.toCharArray();

        // 参数三
        StringBuffer sb=new StringBuffer();

        // 参数四 
        boolean [] used=new boolean[len];

        backtracking(chs,len,sb,used,res);
        // 有重复的，那么就去去重吧 没什么好讲的
        // 再加别的剪枝逻辑真的很难想
        Set <String> set=new HashSet<>();
        for(int i=0;i<res.size();i++){
            if(!set.contains(res.get(i))){
                set.add(res.get(i));
            }        
        }

        String [] ress=new String[set.size()];

        // 现在才知道set中必须用iterator访问数据
        Iterator it=set.iterator();
        int i=0;
        while(it.hasNext()){
            // 这里才知道必须强转
            ress[i]=(String)it.next();
            i++;
        }



        return ress;
    }

    private void backtracking( char [] chs,
                              int len,
                              StringBuffer sb,
                              boolean [] used,
                              List <String> res){
        if(sb.length()==len){
            res.add(new String(sb));
            return;
        }
        for(int i=0;i<chs.length;i++){
            if(used[i]){
               continue; 
            }
            used[i]=true;
            sb.append(chs[i]);
            backtracking(chs,len,sb,used,res);
            used[i]=false;
            sb=sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

[leetcode 266 回文排列]: https://leetcode-cn.com/problems/palindrome-permutation/

给定一个字符串，判断该字符串中==是否==可以通过==重新排列组合==，形成一个回文字符串。

```java
class Solution {
    public boolean canPermutePalindrome(String s) {

        // 如果一个字符串可以组成一个回文串，
        // 那么：(1) 如果它的长度为偶数，那么每个字符都必须出现偶数次；
        // (2) 如果它的长度为奇数，那么除了一个字符出现奇数次以外，其它的字符都必须出现偶数次。
        // 因此可以总结得到，如果一个字符串可以组成一个回文串，那么出现奇数次的字符的数量不能超过 1。
        int len=s.length();
        Map <Character,Integer> map=new HashMap<>();
        for(int i=0;i<len;i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),1);
            }else{
                map.put(s.charAt(i),map.get(s.charAt(i))+1);
            }
        }  
        boolean isOk=true;  

        int count=0;
        for(Character ch:map.keySet()){
            if(map.get(ch)%2!=0 ){
                count++;
                if(count!=1){
                    isOk=false;
                    break;
                }
            }
        }

        return isOk;   

 
        }





    
}
```

#### 子集问题（就是一个组合问题）

子集问题是组合问题

##### leetcode 78 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {

        // 它也是一个组合问题
        // 只是每次递归的深度不同而已
        // 从递归深度二去开始吧  不然没必要
        // 先判断一下

        // 第一个参数
        List <List<Integer>> res=new LinkedList<>();

        // 第二个参数
        int len=nums.length;

        // 第三个参数是递归深度 pos

        // 第四个参数是一个list
        List<Integer> path=new LinkedList<>();

        // 第五个参数 是nums

        res.add(path);
        // 组合一般五个参数
        for(int depth=1;depth<=len;depth++){
            backtracking(nums,depth,0,path,res);

        }

        return res;

        
    }


    private void backtracking(int [] nums,
                              int depth,
                              int pos,
                              List<Integer> path,
                              List <List<Integer>> res){
        if(path.size()==depth){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=pos;i<nums.length;i++){
            path.add(nums[i]);
            // 一定要注意这里是i+1.而不是pos+1
            backtracking(nums,depth,i+1,path,res);
            path.remove(path.size()-1);
        }
    }
}
```

##### leetcode 90 子集II

> 给你一个整数数组 nums ，其中可能**包含重复元素**，请你返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```JAVA
class Solution {

    LinkedList<Integer> path=new LinkedList<>();
    List<List<Integer>> res=new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if(null==nums ||nums.length==0){
            return res;
        }
        // 1.先加一个空的集合再说
        res.add(path);
        // 2.最最最最为基础也是去重技巧的基础：排序
        // 今晚我竟然死在这里
        // 服了
        Arrays.sort(nums);
        // 去重必备，记住组合II中的类似技巧
        boolean [] isVisited=new boolean[nums.length];
        // 从长度1开始
        for(int i=1;i<=nums.length;i++){
            backTracking(0,nums,i,isVisited);
        }

        return res;

    }


    private void backTracking(int start,int [] nums,int targetDepth,
                            boolean [] isVisited){
        if(path.size()==targetDepth){
            res.add(new LinkedList<Integer>(path));
            return;
        }

        for(int i=start;i<nums.length;i++){
            // 还是老规矩 就是那个双指针的三数之和去重的方案
            // 且和组合总和II是一样的去重逻辑
            if(i>0 && nums[i]==nums[i-1] && isVisited[i-1]==false){
                continue;
            }
            isVisited[i]=true;
            path.add(nums[i]);
            backTracking(i+1,nums,targetDepth,isVisited);
            path.removeLast();
            isVisited[i]=false;
        }
    
    
    }
}
```

##### leetcode 491 递增子序列

> 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

这里已然不能排序，没有三数之和的去重逻辑了

```java
class Solution {

    List<List<Integer>> res=new LinkedList<>();
    List<Integer> path=new LinkedList<>();
   

    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracking(0,nums);
        return res;

    }

    private void backTracking(int start,int [] nums){
        // 1. 我们这里没有去return
        if(path.size()>1){
            res.add(new LinkedList<Integer>(path));   
        }

        // 2 .统一递归深度使用同一个set去重
        // 也就是该层级不能再用了
        // 递归到底的情况 没有去return
        // 今天我木了 真的木了 不会不会  把递归树画出来能解决所有回溯问题吗  我不知道  我困了
        Set<Integer> set=new HashSet<>();
        for(int i=start;i<nums.length;i++){
            if((!path.isEmpty()&& nums[i]<path.get(path.size() - 1))
                    ||set.contains(nums[i])){
                continue;
            }
            
            path.add(nums[i]);
            set.add(nums[i]);
            backTracking(i+1,nums);
            path.remove(path.size()-1);
     
        }

    }

}
```



#### 切割问题(也是一个组合问题)

##### leetcode 131 分割回文串

[leetcode 131 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

```java
class Solution {
    public List<List<String>> partition(String s) {

        // 参数一 s

        // 参数二 起始位置 pos
        int pos=0;

        // 参数三 List<String> path
        LinkedList <String> path=new LinkedList<>();

        // 参数四 List<List<String>> res

        List<List<String>> res=new LinkedList<>();

        int len=s.length();

        // 参数五：查询是否为回文串
        boolean [][] f=new boolean[len][len];
        for(int i=0;i<len;i++){
            f[i][i]=true;
        }

        // 对于每个数都去以他为中心点去扩散，然后去判断是否是回文串
        for(int i=0;i<len;i++){
            // 偶数扩散
            int l1=i;
            int r1=i+1;
            while(l1>=0 && r1<len && s.charAt(l1)==s.charAt(r1)){ 
                f[l1][r1]=true;
                l1--;
                r1++;
            }
            // 奇数扩散
            int l2=i-1;
            int r2=i+1;
            while(l2>=0 && r2<len && s.charAt(l2)==s.charAt(r2)){ 
                f[l2][r2]=true;
                l2--;
                r2++;
            }

        
        }

        // 初始化的时候
        backtracking(s,0,f,path,res);
        return res;



    }

    private void backtracking(String s,
                              int pos,
                              boolean [][] isPal,
                              LinkedList<String> path,
                              List<List<String>> res){
        // 分割线
        if(pos==s.length()){
            res.add(new LinkedList<String>(path));
            return;
        }
        for(int i=pos;i<s.length();i++){
            if(isPal[pos][i]){
                // 注意每次的
                path.addLast(s.substring(pos,i+1));
                backtracking(s,i+1,isPal,path,res);
                path.removeLast();

            
            }

        }
    }
}
```

##### leetcode 93 复原IP地址

> 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按 任何 顺序返回答案。
>
> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
>

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {

        List<String> res=new LinkedList<>();
        LinkedList<String> path=new LinkedList<>();
        // 这么简单的剪枝 我竟然不知道  我还去每次都判断
        if (s.length() > 12) 
            return res; 
        backtracking(0,s,path,res);
        return res;
    }


    private void backtracking(int start,String s,LinkedList<String> path,List<String> res){
        
        // 实在是没想到这一点，当长度等于3的时候去判断
        if(path.size()==3 ){
            String merged=path.stream().filter(
                string->!string.isEmpty()).collect(Collectors.joining("."));
            if(isValid(s.substring(start,s.length()))){
                res.add(merged+"."+s.substring(start,s.length()));    
            }
             
            return; 
        }

        for(int i=start;i<s.length();i++){
          
            // 判断是否合法
            String element=s.substring(start,i+1);
            // 注意 不合法是跳过 而不是返回
            if(!isValid(element)){
                //这里break continue return竟然都行
                // 其中continue是在做无用功
                // break 和return是一样的
                // [start,i+2)更不会合法
                break;
            }

            path.addLast(s.substring(start,i+1));
            backtracking(i+1,s,path,res);
            path.removeLast();


        }
    }


    // 怎么感觉在考这个  因为我这个写的不对 泥马
    private boolean isValid(String s){
        if(s==null||s.length()==0){
            return false;
        }

        if (s.charAt(0) == '0' && s.length()!=1) { // 0开头的数字不合法
            return false;
        }
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 如果⼤于255了不合法
                return false;
            }
        }
        return true;
    }
}
```

#### 棋盘问题

##### leetcode 51 N皇后

> n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
>
> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211123203935252.png" alt="image-20211123203935252" style="zoom:50%;" />

```java
class Solution {

//    void backtracking(参数) {
//     if (终止条件) {
//         存放结果;
//         return;
//     }
//     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
//         处理节点;
//         backtracking(路径，选择列表); // 递归
//         回溯，撤销处理结果
//     }
// }

    List<List<String>> res = new ArrayList<>();
    // 递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
    // 每次都是要从新的一行的起始位置开始搜，所以都是从0开始。
    // 递归终止条件 
    public List<List<String>> solveNQueens(int n) {
        // 初始化一个棋盘的默认值
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTracking(n, 0, chessboard);
        return res;

    }

    // n表示要递归的target
    // row代表需要递归的行  启示每次for循环的是每一行的列值 代表的是递归的宽度
    // 而每次递归的过程中是为了遍历不同的行，所以要代入目前递归的行的信息
    // 也就是递归的深度 与以前的startIndex一样
    // 还是不习惯 还是用startIndex吧，
    private void backTracking(int n, /*int row*/ int startIndex, char[][] chessboard){
        if(startIndex==n){
            res.add(new ArrayList<String>(array2List(chessboard)));
        }

        // 因为同一层级之间  行相同 递归的是列
        // 所以这里的是列
        for(int col=0;col<n;col++){
            if(isValid(startIndex,col,n,chessboard)){
               // 放置皇后
               chessboard[startIndex][col] = 'Q';
               backTracking(n, startIndex+1, chessboard);
               // 回退
               chessboard[startIndex][col] = '.'; 
            }
        }
    }

    // 数组转list
    public List array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        // 遍历棋盘的每一行 并添加为一个list
        for (char[] c : chessboard) {
            // 这里直接把字符数组转成string 
            list.add(String.copyValueOf(c));
        }
        return list;
    }


   
    // 作用：检测（row,col）是否合法
    // 因为在递归过程中 递归的宽度是列 
    // 行是不变的  所以要检查的是每一列
    // 而行是不变的
    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        // 检查列的时候需要去遍历之前的行在该列有没有占领
        // 有的话表示这个位置不合法
        for (int i=0; i<row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线
        // 也就是从左上角45度去遍历即可
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        // 右上角45度遍历 i-- j++ i=row-1 j=col+1
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

##### leetcode 37 数独

> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 遵循如下规则：
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }
    // 解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，
    // 相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值
    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                // (i, j) 这个位置放k是否合适
                for (char k = '1'; k <= '9'; k++){ 
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        // 如果找到合适一组立刻返回
                        // 如果找到合适一组立刻返回
                        // 如果找到合适一组立刻返回
                        if (solveSudokuHelper(board)){ 
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        // 判断任意一点(row,col)所属的九宫格  并判断之
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}

```

#### 回溯题海

##### 1. leetcode 22 括号生成 

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> 有效括号组合需满足：左括号必须以正确的顺序闭合。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211123221255880.png" alt="image-20211123221255880" style="zoom:67%;" />

```java
class Solution {
    List<String> res = new LinkedList<>();
    public List<String> generateParenthesis(int n) {
        if (n == 0) return null;
        StringBuilder path = new StringBuilder();
        backtrack(path, n, 0, 0);
        return res;
    }
    
    void backtrack(StringBuilder path, int n, int left, int right) {
        //结束条件，左右括号相等?
        if (left == n && right == n) {
            String s = path.toString();
            res.add(s);
            return;
        }
        if (left > n || right > n)
            return;
        // 用掉的右括号大于左括号则返回
        if (right > left)
            return;
        //增加左括号
        path.append('(');
        // 1. 一直增加左括号  直到用掉的右括号大于左括号  则可以返回
        backtrack(path, n, left + 1, right);
        // 2. 一旦右括号多用了  则删除该右边括号
        path.deleteCharAt(path.length() - 1);
        // 3. 开始添加左括号
        path.append(')');
        backtrack(path, n, left, right + 1);
        path.deleteCharAt(path.length() - 1);
    }


}
```

##### 2. leetcode 79 单词搜索

> 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211129221710850.png" alt="image-20211129221710850" style="zoom:50%;" />

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int m=board.length;
        int n=board[0].length;
        boolean [][] isVisited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                 boolean flag=dfs(board,word,i,j,0,isVisited);
                 if(flag){
                     return true;
                 }
            }
        }
       
        return false;

    }

    // 从i，j  能否遍历完从it开始的整个字符串
    private boolean dfs(char[][] board,String word,int x,int y,int it,boolean[][] isVisited){
         if (board[x][y] != word.charAt(it)) {
            return false;
        } else if (it == word.length() - 1) {
            return true;
        }
        // 匹配了一个字母 且不是末尾
        isVisited[x][y] = true;
        // 四个方向 
        // 我的确没想到定义搜索方向  我之前都是一个个回溯
        int [][] direction={{0,1},{0,-1},{1,0},{-1,0}};
        boolean res=false;

        for(int [] dir:direction ){
            int nx=x+dir[0];
            int ny=y+dir[1];
            // 注意这里千万不要用x，y去增减  因为回退的时候根本不知道怎么回退
            // 所以这里记住x,y即可
            if(nx>=0 && nx<board.length && ny>=0 && ny<board[0].length  && !isVisited[nx][ny]){
                boolean flag=dfs(board,word,nx,ny,it+1,isVisited);
                if(flag){
                    // 已经找到了 不是return 而是直接跳出当前循环
                    res=true;
                    break;
                }
            }
        }
        // 这里才是回退 
        isVisited[x][y]=false;
        // 不管结果如何  把res返回
        return res;   
    }
}
```

##### 3. leetcode 113 路径总和II

> 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
>
> 叶子节点 是指没有子节点的节点。

所以说树的dfs很不一样，以前有数组或者list的dfs，或者图的dfs，这里是树的dfs，习惯就好。

```JAVA
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private LinkedList<Integer> path = new LinkedList<>();
    private List<List<Integer>> res = new LinkedList<>();


    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root,targetSum);
        return res;
    }

    
    private void dfs(TreeNode itNode, int targetSum) {
        if(itNode==null){
            return;
        }
        path.add(itNode.val);
        targetSum -= itNode.val;
        if (itNode.left == null && itNode.right == null && targetSum == 0) {
            res.add(new LinkedList<>(path));
        }
        dfs(itNode.left, targetSum);
        dfs(itNode.right, targetSum);
        // 这里才回溯 上面两个递归的targetSum其实是一样的
        path.removeLast();

    }
}

```

##### 4. leetcode 89 格雷编码

> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211201223326816.png" alt="image-20211201223326816" style="zoom:67%;" />

```java
class Solution {

     List<Integer> res = new ArrayList<>();
    public List<Integer> grayCode(int n) {
        backtrace(n,new StringBuffer(),new int[]{0,1});
        return res;
    }
    public void backtrace(int n, StringBuffer sb, int[] nums){
        //判断条件，是否返回
        if(sb.length() == n){
            // 二进制转换为十进制
            res.add(Integer.valueOf(sb.toString(),2));
            return;
        }
        // 回溯第一个状态
        sb.append(nums[0]);
        //注意数组
        backtrace(n,sb,new int[]{0,1});
        sb.deleteCharAt(sb.length()-1);
        // 回溯第二个状态
        sb.append(nums[1]);
        //注意数组
        backtrace(n,sb,new int[]{1,0});
        sb.deleteCharAt(sb.length()-1);
    }

}
```

不要只会在一个for循环里回溯

##### 5. leetcode 254  因子的组合

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211201223425824.png" alt="image-20211201223425824" style="zoom:67%;" />

```java
class Solution {
    public List<List<Integer>> getFactors(int n) {
        return dfs(n, 2);
    }
    
    private List<List<Integer>> dfs(int n, int start) {

        // start一定是
        List<List<Integer>> res = new LinkedList<>();
        // 1. i*i<=n这一点不难想到吧
        for (int i = start; i*i <= n; i++) {
            if (n % i != 0) {
                continue;
            }
            LinkedList<Integer> path = new LinkedList<>();
            path.add(i);
            path.add(n / i);
            res.add(path);
            // 下一次迭代从i开始  而不再从2开始,而是从i开始
            // 3.下一次迭代从i开始  保证下一次的分解过程不会遇到比以前小的因子  
            // 故而能去重
            List<List<Integer>> lists  = dfs(n / i, i);
            for (List<Integer> list : lists) {
                // 2.注意lists 收集的结果是n/i的分解的合集
                // 所以要在里面加上i的因子等于总结果
                // 2.1 故而加上i的因子
                list.add(i);
                res.add(list);
            }

        }

        return res;

    }
    
}
```

其实这里算纯粹的dfs，而不是所谓的回溯，这里根本没有回退。

##### 6. leetcode 306 累加数

> <img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211202223445638.png" alt="image-20211202223445638" style="zoom:67%;" />

```java
class Solution {
    public boolean isAdditiveNumber(String num) {
        return dfs(num, 0, 0, 0, 0);
    }

    /**
     * @param num    原始字符串
     * @param index  当前处理下标 为的就是把当前数当作一个独立的单元去处理
     *               然后你就想  如果当前处理的数知道了  那么之前的和不也就要知道吗
     *               不断求出当前值cur
     * @param sum    如上解释需要sum
     * @param pre    在递归过程中如何pre+cur就可以去迭代sum
     * @param kOrder 当前是处理的第几个数字 具体见下面的解释
     */
    private boolean dfs(String num, int index,
                        long sum, long pre,
                        int kOrder) {
        // 至少迭代到字符串末尾时，必须处理的数要大于2，
        // 因为必须处理到的数是和  和必须在是第三个数
        if (index == num.length()) {
            return kOrder > 2;
        }
        for (int it = index; it < num.length(); it++) {
            // 1. 每次处理一个数  并把该数的值与前面两个数的总和比较
            // 默认的初始的总和值是0
            // 传入前面的两数之和真的妙
            long cur = getLRValue(num, index, it);
            // 剪枝：无效数字
            if (cur < 0) {
                return false;
            }
            // 剪枝：当前数字不等于前面两数之和   则继续咯
            if (kOrder >= 2 && cur != sum) {
                continue;
            }
            // 2、从it+1开始迭代
            // 更新sum为pre+cur
            if (dfs(num, it + 1, pre + cur, cur, kOrder + 1)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 获取 left ~ right 组成的有效数字
     */
    private long getLRValue(String num, int left, int right) {
        if (left < right && num.charAt(left) == '0') {
            return -1;
        }
        long res = 0;
        while (left <= right) {
            res = res * 10 + num.charAt(left) - '0';
            left++;
        }
        return res;
    }
}


```



## 七、（四星重要）动态规划

矩阵网格，只能向右或者向下走一步

题A：有多少种方式可以走到右下角  	DP

题B：输出所有到右下角的路径 		回溯

==计数、存在性、最值==适合使用dp

### 7.1 适应问题

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729164441152.png" alt="image-20210729164441152" style="zoom:67%;" />

### 7.2 坐标型动态规划

给定一个序列或网格，需要找到序列中某些子序列或网格种的某条路径(==计数、最值、存在性==)

注意：坐标型动态规划一定是以序列中==<font color=red>某个数结尾的性质</font>==作为状态变量

#### lintcode 397 最长上升连续子序列

> 给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列的长度。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）

<font color=red>某个数结尾的性质</font>

<font color=red>某个数结尾的性质</font>

<font color=red>某个数结尾的性质</font>

强调一万遍，因为单调性的问题一定是以该数为结尾最好做

```latex
f[i]=max{1,f[i-1]+1|i>0 and a[i-1]<a[i]}
// 然后求一个max f[i]就好
```

```java
public class Solution {
    /**
     * @param A: An array of Integer
     * @return: an integer
     */
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if(A==null||A.length==0){
            return 0;
        }
        // write your code here
        int len=A.length;
        // 从左到右递增
        // int [] fl=new int[len];
        // fl[0]=1;
        // 这里挑战O(1)的空间
        int res=1;
        // 遍历的指针
        int it =1;
        for(int i=1;i<len;i++){
            if(A[i-1]<A[i]){
                it++;
            }else{
                it=1;
            }
            res=res>it?res:it;
        }
        // 重新为1
        it=1;
        for(int j=len-2;j>=0;j--){
            if(A[j]>A[j+1]){
                it++;
            }else{
                it=1;
            }
            res=res>it?res:it;
        }

        return res;
    }
}
```

#### lintcode 110 最小路径和

>  给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。
>
>  你在同一时间只能向下或者向右移动一步

```java
public class Solution {
    /**
     * @param grid: a list of lists of integers
     * @return: An integer, minimizes the sum of all numbers along its path
     */
    public int minPathSum(int[][] grid) {
        // write your code here
        int m=grid.length;
        int n=grid[0].length;

        //f[i][j]=min{f[i-1][j],f[i][j-1]}+grid[i][j]
        int [][] f=new int[m][n];
        f[0][0]=grid[0][0];
    
        // 注意这里是n因为变化的是列
        for(int i=1;i<n;i++){
            f[0][i]=f[0][i-1]+grid[0][i];   
        }

        // 这里变化的是行  注意
        for(int j=1;j<m;j++){
            f[j][0]=f[j-1][0]+grid[j][0];   
        }

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                f[i][j]=Math.min(f[i-1][j],f[i][j-1])+grid[i][j];
            }
        }

        return f[m-1][n-1];

    }
}
```

#### lintcode 115 不同的路径 II

> "[不同的路径](http://www.lintcode.com/problem/unique-paths/)" 的跟进问题：
>
> 现在考虑网格中有障碍物，那样将会有多少条不同的路径？
>
> 网格中的障碍和空位置分别用 1 和 0 来表示。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729180511496.png" alt="image-20210729180511496" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729180629625.png" alt="image-20210729180629625" style="zoom:67%;" />

```java
public class Solution {
    /**
     * @param obstacleGrid: A list of lists of integers
     * @return: An integer
     */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // write your code here
        int m=obstacleGrid.length;
        int n=obstacleGrid[0].length;

        int [][] f=new int[m][n];

        // f[0][0]初始值
        if(obstacleGrid[0][0]==0){
            f[0][0]=1;
        }

        // 如果这个格子是障碍物的话
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(obstacleGrid[i][j]==1){
                    f[i][j]=0;
                }
            }
        }

        // 第一行
        for(int i=1;i<n;i++){
            if(obstacleGrid[0][i]==0){
                f[0][i]=f[0][i-1];
            }    
        }

        // 第一列
        for(int j=1;j<m;j++){
            if(obstacleGrid[j][0]==0){
                f[j][0]=f[j-1][0];
            }    
        }

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==0){
                    f[i][j]=f[i-1][j]+f[i][j-1];
                }
            }
        }
        return f[m-1][n-1];
       
    }
}
```

#### lintcode 553 炸弹袭击

> 给定一个二维矩阵, 每一个格子可能是一堵墙 `W`,或者 一个敌人 `E` 或者空 `0` (数字 '0'), 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会==杀死所有在同一行和同一列没有墙阻隔的敌人==。 由于墙比较坚固，所以墙不会被摧毁.
>
> 你只能在空的地方放置炸弹.

这个待定  比较复杂

### 7.3 序列型动态规划

更偏向于决策性问题

序列型动态规划的==每个元素的某种性质==是动态规划过程中必须考虑的

注意这里的==数组开的比原本的大1==

#### lintcode 515 房屋染色

> 这里有`n`个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得**相邻的房屋颜色不同**，并且费用最小，返回最小的费用。
>
> 费用通过一个`n`x`3` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染红色的费用，`cost[1][2]`表示房屋`1`染绿色的费用，依此类推。找到油漆所有房子的最低成本。
>
> 所有费用都是正整数

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729212949901.png" alt="image-20210729212949901" style="zoom:80%;" />

请注意==前i栋房子的概念，第i栋对应的下标为i-1==

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729213303682.png" alt="image-20210729213303682" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729214017647.png" alt="image-20210729214017647" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729214057022.png" alt="image-20210729214057022" style="zoom:67%;" />



```java
public class Solution {
    /**
     * @param costs: n x 3 cost matrix
     * @return: An integer, the minimum cost to paint all houses
     */
    public int minCost(int[][] costs) {
        // write your code here
        int n=costs.length;

        // 初始化  
        // 为什么序列型动态规划需要开的数组多一行，
        // 因为多一行容易得到初始化值
        int [][] f=new int[n+1][3];
        f[0][0]=f[0][1]=f[0][2]=0;
        
       
        // 是不是会写表达式  但不会写所需的for循环
        // 你个小辣鸡
        for(int i=1;i<n+1;i++){
            for(int j=0;j<3;j++){
                int tmp=Integer.MAX_VALUE;
                for(int k=0;k<3;k++){
                    // 这里比较的是f[i-1][k],因为f[i-1][k]表示的是第i-1个房屋（在这里即前一个房屋）
                    // 染成第k种颜色的值
                    // 在i=1时，将会得到f[0][k],即0
                    if(k!=j){
                        tmp=tmp>f[i-1][k]?f[i-1][k]:tmp;
                    }
                }
                // costs[i-1][j]表示第i个房子（在数组中对应于坐标i-1），油漆成第j种颜色的成本
                f[i][j]=tmp+costs[i-1][j];
            }
        }
        
        return Math.min(f[n][0],Math.min(f[n][1],f[n][2]));

    }
}
```

#### lintcode 516 房屋染色 II

> 这里有`n`个房子在一列直线上，现在我们需要给房屋染色，共有`k`种颜色。每个房屋染不同的颜色费用也不同，你希望每两个相邻的房屋颜色不同
>
> 费用通过一个`n`x`k` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染颜色`0`的费用，`cost[1][2]`表示房屋`1`染颜色`2`的费用。找到油漆所有房子的最低成本。

暂时不总结

#### lintcode 392 打劫房屋

> 假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 **当相邻的两个房子同一天被打劫时，该系统会自动报警**。
>
> 给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，**在不触动报警装置的情况下**, 你最多可以得到多少钱 。

性质就是==每间房屋到底偷还是不偷==

用`f[i][0]`表示不偷房子`i-1`的前提下，前`i`栋房子最多偷多少金币

用`f[i][1]`表示偷房子`i-1`的前提下，前`i`栋房子最多偷多少金币

`f[i][0]=max{f[i-1][0],f[i-1][1]}`:==因为不偷房子i-1（第i栋房屋），所以房子i-2（第i-1栋房屋）可以选择偷或者不偷==

`f[i][1]=f[i-1][0]+A[i-1]`:==其实`f[i-1][0]`代表了`f[i-2]`的所有状态==

其实可以消去一个状态，就是说，在偷`i`的情况下，最多能偷的金币与`i-2`栋偷不偷有关

`f[i]=max{f[i-1],f[i-2]+A[i-1]}`

```java
public class Solution {
    /**
     * @param A: An array of non-negative integers
     * @return: The maximum amount of money you can rob tonight
     */
    public long houseRobber(int[] A) {
        if(null==A||A.length==0){
            return 0;
        }
        // write your code here
        int n=A.length;
        long [] f=new long[n+1];
        f[0]=0;
        f[1]=A[0];
       

        for(int i=2;i<n+1;i++){
            f[i]=Math.max(f[i-1],f[i-2]+A[i-1]);
        }

        return f[n];

    }
}
```

<img src="%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0.assets/image-20210729231644267.png" alt="image-20210729231644267" style="zoom:67%;" />

### 7.4 划分型动态规划

划分型动态规划：

> 给定==长度为N的序列或字符串==，要求==划分为若干段==
>
> 段数不限，或指定K段
>
> 每一段满足一定的性质
>
> ==划分型动态规划的数组长度是`n+1`==



#### lintcode 513 完美平方

> 描述
>
> 给一个正整数 n, 请问最少多少个完全平方数(比如1, 4, 9...)的和等于n。

状态：设`f[i]`表示i最少被划分为几个完全平方数之和

`f[i]=min{f[i-j*j]+1} (1<=j*j<=i)`

```java
public class Solution {
    /**
     * @param n: a positive integer
     * @return: An integer
     */
    public int numSquares(int n) {
        // write your code here
        int [] f=new int[n+1];
        f[0]=0;
     

        
        for (int i = 1; i <= n; ++i) {
            f[i]=Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; ++j) {
                f[i] = Math.min(f[i], f[i - j * j] + 1);
            }
        }
        
      
        return f[n];
    }
}
```

#### lintcode 108 分割回文串（leetcode 132 分割回文串II）

> 给定字符串 `s`, 需要将它分割成一些子串, 使得每个子串都是回文串.
>
> 最少需要分割几次?
>
> *s*.*l**e**n**g**t**h*<=2000

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210729235326099.png" alt="image-20210729235326099" style="zoom:50%;" />

状态：设`s`前`i`个字符`s[0,i-1]`表示最少可以划分为`f[i]`个字符串

`f[i]=min{f[j]+1|s[j,i-1]是回文串} (j=0,1,2,...,i-1)`

```java
public class Solution {
    /**
     * @param s: A string
     * @return: An integer
     */
    public int minCut(String s) {
        // write your code here
        int n=s.length();
        int [] f=new int[n+1];
        // 划分型为什么数组长度为什么一定要多一个
        // 这是因为前i个字符串对应的是标号i-1的数据
        // 就是有几个回文子串
        f[0]=0;
  
        boolean [][] isPal=isPal(s);
        for(int i=1;i<n+1;i++){
            f[i]=Integer.MAX_VALUE;
            for(int j=0;j<i;j++){
                // 如果s[j,i-1]是回文串
                if(isPal[j][i-1]){
                    f[i]=Math.min(f[i],f[j]+1);
                }
                

            }
        }

        return f[n]-1;


       

       
    }



    private boolean [][] isPal(String s){

        char [] chs=s.toCharArray();
        int n=s.length();

        boolean[][] f=new boolean[n][n];
        // 这个部分竟然忘了 我说呢
        // 不能忍
        // 不能忍
        // 不能忍
        for(int i=0;i<n;i++){
            f[i][i]=true;
        }
        for(int i=0;i<n;i++){
            int l1=i;
            int r1=i+1;
            while(l1>=0 && r1<n && chs[l1]==chs[r1]){
                f[l1][r1]=true;
                l1--;
                r1++;
            }
            int l2=i-1;
            int r2=i+1;
            while(l2>=0 && r2<n && chs[l2]==chs[r2]){
                f[l2][r2]=true;
                l2--;
                r2++;
            }
        }
        return f;
    }
}
```

#### lintcode 437 抄写书籍

> 描述
>
> 给定`n`本书，第`i`本书有`[i]页`。有`k`个人来抄这些书。
>
> 这些书排成一行，每个人都可以索取连续一段的书。例如，一个复印机可以连续地将书从第`i`册复制到第`j`册，但是他不能复制第1册、第2册和第4册（没有第3册）。
>
> 他们在同一时间开始抄书，每抄一页书都要花1分钟。为了让最慢的复印机能在最早的时间完成书的分配，最好的策略是什么？
>
> 请返回最慢复印机花费的最短时间。

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211205210158343.png" alt="image-20211205210158343" style="zoom:67%;" />

==以上是最少划分多少段==

这里==划分为k段==

这里是划分为k段，使得时间最短的k段中的最大一段（木桶原理）

`f[k][i]=min{max{f[k-1][j],A[j]+A[j+1]+...+A[i-1]}}(其中j=0,1,2,...i)`

最后一步：最优策略中抄写员抄写的是`A[j]+A[j+1]+...+A[n-1]`

需要知道前k-1个人最少抄写完前j本书的最少时间

下面是转移方程

`f[k][i]=min{max{f[k-1][j],A[j]+A[j+1]+...+A[i-1]}}(其中j=0,1,2,...i)`

```java
public class Solution {
    public int copyBooks(int[] pages, int   person) {
        // write your code here
        // 设f[k][i]为k个抄写员抄写i本书所花的时间
        // 也就是把如果本书划分为k段
        // 这里是划分为k段，使得时间最短的k段中的最大一段（木桶原理）
        // f[k][i]=min{max{f[k-1][j],A[j]+A[j+1]+...+A[i-1]}}(其中j=0,1,2,...i)
        // 注意min的写法默认第一个值代入得是自己  在把自己设置为最大值的前提下
        if(pages==null||pages.length==0){
            return 0;
        }
        int page=pages.length;
        if(person>page){
            person=page;
        }

        int [][]f=new int[person+1][page+1];
        f[0][0]=0;
        // 1. 0个人抄写n本书
        for(int i=1;i<page+1;i++){
            f[0][i]=Integer.MAX_VALUE;
        }

        // 迭代人数 k
        for(int k=1;k<person+1;k++){
            // 2. k 个人抄0本书
            // 这里的初始化忘了 实在不应该 可以放在外面去初始化
            f[k][0]=0;
            // 迭代书数目
            for(int i=1;i<page+1;i++){
                // 3.定义f[k][i]
                f[k][i]=Integer.MAX_VALUE;
                // 从后面数是为了计算sum方便
                int sum=0;
                for(int j=i;j>=0;j--){
                    f[k][i]=Math.min(f[k][i],Math.max(f[k-1][j],sum));
                    // 从i迭代到j
                    if(j>0){
                        sum+=pages[j-1];
                    }
                }
            }
        }
        return f[person][page];

    }

}
```

### 7.5 博弈型动态规划

一方先下，在一定规则内依次出招

如果满足一定条件，则一方胜

#### lintcode 394  石子游戏

> 有一排N个石子，Alice和Bob两人轮流取石子
>
> 每人只能从最右边取走一个或者两个石子
>
> 取走最后石子的必胜
>
> 问先手是否必胜

```java
public class Solution {
    /**
     * @param n: An integer
     * @return: A boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        if(n==0){
            return false;
        }
        // write your code here
        if(n==1||n==2){
            return true;
        }
        boolean [] f=new boolean[n+1];
        f[0]=false;
        f[1]=f[2]=true;
        
        // 只要f[i-1]或者f[i-2]赢不了  则先手必胜
        for(int i=3;i<n+1;i++){
            if(!f[i-1]||!f[i-2]){
                f[i]=true;
            }
        }
        return f[n];
    }
}
```

博弈型动态规划的实质在于==面对多回合你不知道如何决策，但如果只剩一两回合了，那么胜负显而易见。==

所以说你需要做的是大胆假设你遇到的任何决策的输赢，即==以面对的数量为变量，定义输赢函数==，很显然的定义==面对它在哪些情况下会赢或者输==

也就是说，`先手必输的比赛在于对手面对剩下的情况无论如何都会赢`

这里也就是`f[i]=false,当f[i-1]和f[i-2]都为true`

也就是`f[i]=true,当f[i-1]或者f[i-2]为false`，这表示，先手总有办法要赢

博弈型动态规划==先手必胜==的原则是：只要==对手面对剩下的局面有输的可能==，那么==先手总会赢==，因为先手一定让对手只能存在输的可能。

### 7.6 背包问题

##### lintcode 92 背包问题I

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211208215727710.png" alt="image-20211208215727710" style="zoom:50%;" />

背包问题的最大原则是：

永远把**背包重量作为状态序列**，即**考虑0-背包重量的每个重量是否能进入背包**

在这题中，==前i个物品是否能拼出重量w==（w的范围为0-背包重量）即为本题的状态变量

即令`f[i][w]表示前i个物品是否能拼出重量w`

`f[i][w]=f[i-1][w]ORf[i-1][W-A[i-1]]`

即要求前i个物品是否能拼出重量w，==如果前i-1个能拼出，那么前i个物品即可拼出==

==如果前i-1个物品能拼出w-A[i-1]，那么前i个物品也能拼出w==

```java
public class Solution {

    public int backPack(int m, int[] A) {

        if(A==null||A.length==0){
            return 0;
        }

        // f[i][w]=f[i-1][w]ORf[i-1][W-A[i-1]]
        int sum=0;
        for(int i:A){
            sum+=i;
        }
        if(sum<=m){
            return sum;
        }

        int length=A.length;

        boolean [][]f=new boolean[length+1][m+1];
        // 已经初始化了第一列  其实默认第一行是false  所以也初始化了
        for(int i=0;i<length+1;i++){
            f[i][0]=true;
        }
        for(int i=1;i<length+1;i++){
            for(int w=1;w<m+1;w++){
                f[i][w]=f[i-1][w];
                if(A[i-1]<=w){
                    f[i][w]|=f[i-1][w-A[i-1]];
                }
            }
        }

        // 收集最大数量使得f[length][res]为true的最大res
        int res=0;
        for(int i=m;i>=0;i--){
            if(f[length][i]){
                res=i;
                break;
            }
        }

        return res;


    }
}
```

##### lintcode 563 背包问题V （其实是组合问题，可以用回溯法解）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211209222456130.png" alt="image-20211209222456130" style="zoom:50%;" />

```JAVA
public class Solution {
    /**
     * @param nums: an integer array and all positive numbers
     * @param target: An integer
     * @return: An integer
     */
    public int backPackV(int[] nums, int target) {
        // write your code here

        int len=nums.length;
        int [][] f=new int[len+1][target+1];
        // 注意 一定是1 比如f[1][5]=f[0][5]+f[0][0] 显然f[0][5]为0 所以f[0][0]=1
        //    // f[i][w]=f[i-1][w]+f[i-1][w-nums[i-1]]
        // f[4][5]=f[3][5]+f[3][0] f[3][0]=1其实 表示第四个数是5
        // 前三个数的方案数加上第四个数5为最终方案数
        // 所以f[i][0]=1
        for(int i=0;i<len+1;i++){
            f[i][0]=1;
        }
        for(int i=1;i<target+1;i++){
            f[0][i]=0;
        }

        for(int i=1;i<len+1;i++){
            for(int w=1;w<target+1;w++){
                f[i][w]=f[i-1][w];
                if(w>=nums[i-1]){
                    f[i][w]+=f[i-1][w-nums[i-1]];
                }
            }
        }

        return f[len][target];

     
    }
}
```

##### lintcode 564 背包问题VI（其实是排列问题，回溯法解过）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211210213206891.png" alt="image-20211210213206891" style="zoom:50%;" />

这里的最后一步已经不是考虑最后一个物品是否进入背包了

而应该是==最后一个物品的重量是多少==

因为==这里的每个数可以取多个==

==如果最后一个物品的重量是`nums[0]`,则需要求的是有多少种组合拼成`target-nums[0]`==

==如果最后一个物品的重量是`nums[1]`,则需要求的是有多少种组合拼成`target-nums[1]`==

依此类推

设`f[i]为有多少种组合能够拼得重量i`则求的是`f[target]`

则通项公式是`f[i]=f[i-nums[0]]+f[i-nums[1]]+f[i-nums[2]]+...+f[i-nums[n-1]]`

初始条件：`f[0]=1`

```java
class Solution {
    
    public int backPackVI(int[] nums, int target) {
        // write your code here
        int[] f = new int[target + 1];

        f[0] = 1;

        for (int i = 1; i <= target; i++) {
            f[i] = 0;
            for (int j = 0; j < nums.length; j++) {
                if (i >= nums[j]) {
                    f[i] += f[i - nums[j]];
                }
            }
        }

        return f[target];
    }

}
```

##### lintcode 125 背包问题II

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211211203023893.png" alt="image-20211211203023893" style="zoom:50%;" />

==最后一步：最后一个物品是否能进入背包==

思路：

如果对于每个总重量，我们都知道对应的最大价值是多少，那么我们就知道答案

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211211203646066.png" alt="image-20211211203646066" style="zoom:50%;" />

==对于重量`w`==，如果前`n-1`个物品能够拼出的最大总价值是`v`,那么前`n`个物品也能拼出重量`w`,并且最大总价值也是`v`(<font color=red>也即对于每个重量,第`n`个物品不进入背包的情况</font>)

==对于重量`w`==,如果前`n-1`个物品拼出的是`w-A[n-1]`，最大总价值是`v`,那么前`n`个物品能够拼出重量`w`,总价值为`v+v[n-1]`(<font color=red>也即对于每个重量,第`n`个物品进入背包的情况</font>)

==状态：==设`f[i][w]`为用前i个物品拼出重量`w`时的最大总价值；状态定义的分为以上两种情况，==即第i个物品是否进入背包==

<font color=red>不进入背包，则`f[i][w]=f[i-1][w]`</font>)

<font color=red>进入背包，则`f[i][w]=f[i-1][w-A[i-1]]+v[i-1]`</font>)

所以`f[i][w]=max{f[i-1][w],f[i-1][w-A[i-1]]+v[i-1]|w>=A[i-1]且f[i-1][w-A[i-1]]!=-1}`

==初始条件:==`f[0][0]=0，f[0][1...w]=-1表示0个物品无价值`

```JAVA
public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
     // f[i][w]=max{f[i-1][w],f[i-1][w-A[i-1]]+v[i-1]|w>=A[i-1]且f[i-1][w-A[i-1]]!=-1}
    public int backPackII(int m, int[] A, int[] V) {

        int n=A.length;
        int [][] f=new int[n+1][m+1];
        f[0][0]=0;
        for(int i=1;i<m+1;i++){
            f[0][i]=-1;
        }

        // 记录最大值
        int res=0;
        for(int i=1;i<n+1;i++){
            for(int w=1;w<m+1;w++){
                f[i][w]=f[i-1][w];
                // // f[i][w]=max{f[i-1][w],f[i-1][w-A[i-1]]+v[i-1]|w>=A[i-1]且f[i-1][w-A[i-1]]!=-1}
                if(A[i-1]<=w && f[i-1][w-A[i-1]]!=-1){
                    f[i][w]=Math.max(f[i][w],f[i-1][w-A[i-1]]+V[i-1]);
                }
                if(f[i][w]!=-1){
                    res=Math.max(res,f[i][w]);
                }
            }
        }

        return res;
    }
}
```

##### lintcode 440 背包问题III

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211212221831903.png" alt="image-20211212221831903" style="zoom:50%;" />

现在`Ai`有无穷多个，可以有0个、1个、2个，...

所以无法用前i个物品拼w时的价值来判断

但用==前i种拼w时的价值就没问题了==

设`f[i][w]=`用==前i种==拼出重量w时的最大总价值（-1表示不能拼出w）

那么对于第i种，它会使用到0，1，2，...k个，那么对前其取最大值就行了。==也就是以下的方案：==

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211212222333438.png" alt="image-20211212222333438" style="zoom:67%;" />

<font color=red>以上公式很好理解，你别说你看不懂</font>

但是以上的公式空间复杂度太高，进一步分析

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211212222916719.png" alt="image-20211212222916719" style="zoom:67%;" />

`f[i][w-A[i-1]]=max{f[i-1][w-A[i-1]],f[i-1][w-A[i-1]]+V[i-1]+...}`表示的是用==前i种拼重量`w-A[i-1]`的最大价值==，从`f[i][w]`和`f[i][w-A[i-1]]`的意义上看，==两者只是差了一个`A[i-1]`而已，在价值上差了`V[i-1]`==

<font color=red>通过细心比较会发现，`f[i][w]`的通项公式后面从第二项开始，其实就是`f[i][w-A[i-1]]+V[i-1]`</font>

所以最终简化的状态转移方程为

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211212224305906.png" alt="image-20211212224305906" style="zoom:67%;" />

==其实也是分了两个状态：==

1. **第`i`个物品一个都不需要，拼成w，即`f[i-1][w]`**
2. **前`i`个物品至少需要一个,即`f[i][w-A[i-1]]+V[i-1]`**

```java
public class Solution {
    /**
     * @param A: an integer array
     * @param V: an integer array
     * @param m: An integer
     * @return: an array
     */
    public int backPackIII(int[] A, int[] V, int m) {
        // write your code here
        int n=A.length;
        int [][]f=new int[n+1][m+1];

        for(int i=1;i<m+1;i++){
            f[0][i]=-1;
        }
        // 其实默认了f[i][0]=0;

        int res=0;
        for(int i=1;i<n+1;i++){
            for(int w=1;w<m+1;w++){
                f[i][w]=f[i-1][w];
                if(w>=A[i-1] && f[i][w-A[i-1]]!=-1){
                    // f[i][w]=max{f[i-1][w],f[i][w-A[i-1]]+V[i-1]}
                    f[i][w]=Math.max(f[i][w],f[i][w-A[i-1]]+V[i-1]);
                }

                if(f[i][w]!=-1){
                    res=Math.max(f[i][w],res);
                }
            }
        }
        return res;

    }
}
```

##### 小结

**背包问题I <font color=red>可行性背包</font>**

题面：**求不超过target的最大重量**

==题解：`f[i][w]表示前i个物品是否能拼出重量w`==

`f[i][w]=f[i-1][w]ORf[i-1][W-A[i-1]]`，倒序求使得`f[i][w]`为true的最大重量

**背包问题V、VI<font color=red>计数型背包</font>**

题面:**求有多少种方式拼出重量w**

==限制不能重复==，则最后一步是最后一个==物品==是否能进入背包，`f[i][w]=f[i-1][w]+f[i-1][w-nums[i-1]]`

==无重复限制==，则最后一步是最后一个==重量==是否能进入背包，`f[i]=f[i-nums[0]]+f[i-nums[1]]+f[i-nums[2]]+...+f[i-nums[n-1]]`，其种`f[0]=1`

**背包问题II、III<font color=red>最值型背包</font>**

题面：**要求最大价值**

==限制不能重复==，则最后一步是最后一个==物品==是否能进入背包，`f[i][w]=max{f[i-1][w],f[i-1][w-A[i-1]]+v[i-1]|w>=A[i-1]且f[i-1][w-A[i-1]]!=-1}`

==无重复限制==，则最后一步是最后一个==重量==是否能进入背包，`f[i][w]=max{f[i-1][w],f[i][w-A[i-1]]+V[i-1]}`,==记住最后后一部分是至少第i个重量会被选择一个==

### 7.7 区间型动态规划(尚待记忆化搜索优化)

给定一个序列/字符串，进行一些操作

• ==最后一步==会将==序列/字符串去头/去尾==

• 剩下的会是一个区间[i, j]

• 状态自然==定义为`f[i][j]`，表示面对子序列`[i, …, j]`时的最优性质==

#### lintcode 667 最长回文子序列

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211213202003993.png" alt="image-20211213202003993" style="zoom: 50%;" />

==令`f[i][j]`表示为区间`[i,j]`的最长回文子序列==

对于任意的区间`[i,j]`,如果`s[i]==s[j]`,则`f[i][j]=f[i-1][j-1]+2`

否则，`f[i][j]=max{f[i+1][j],f[i][j-1]}`的最大值

==也就是`f[i][j]=max{f[i+1][j],f[i][j-1],f[i-1][j-1]+2|s[i]=s[j]}`==

初始条件`f[0][0]=f[1][1]=...=f[n-1][n-1]=1`

如果`s[i]=s[i+1]`，则`f[i][i+1]=2`,否则`f[i][i+1]=1`

注意，区间型动态规划不能按照i的顺序来计算，==而应该按照长度来计算==

即先计算`f[0][0],f[1][1],...f[n-1][n-1]`

`f[0][1],f[1][2],...f[n-2][n-1]`

`...`

`f[0][n-1]`

```java
public class Solution {
    /**
     * @param s: the maximum length of s is 1000
     * @return: the longest palindromic subsequence's length
     */
    public int longestPalindromeSubseq(String s) {
        // write your code here
        int n=s.length();

        int [][]f=new int[n][n];

        // 初始化条件
        for(int i=0;i<n;i++){
            f[i][i]=1;
        }

        // l=1表示长度为2
        for(int l=1;l<n;l++){
            for(int i=0;i+l<n;i++){
                // 以长度来迭代  
                f[i][i+l]=Math.max(f[i+1][i+l],f[i][i+l-1]);
                if(s.charAt(i)==s.charAt(i+l)){
                    f[i][i+l]=Math.max(f[i][i+l],f[i+1][i+l-1]+2);
                }
            }
        }

        return f[0][n-1];
    }
}
```

==进阶，如何求最长的公共子序列，而不仅仅是长度==

```java
package com.dexlace;

import java.util.Arrays;

public class Solution {
    public int longestPalindromeSubseq(String s) {
        // write your code here
        int n = s.length();

        int[][] f = new int[n][n];
        /////////////////////////////////////////////////
        // 拓展 如何把最长的回文子序列打出来
        // 1.1 方法：记录标志
        int[][] mark = new int[n][n];
        // 只有当首尾相等时，才能记录其值，别的不需要记住
        // 但是需要记住f[i][j]到底是f[i+1][j]还是f[i][j-1]
        // 以便搜索
        /////////////////////////////////////////////////
        // 初始化条件
        for (int i = 0; i < n; i++) {
            f[i][i] = 1;
        }

        // l=1表示长度为2
        for (int l = 1; l < n; l++) {
            for (int i = 0; i + l < n; i++) {
                // 以长度来迭代
                f[i][i + l] = Math.max(f[i + 1][i + l], f[i][i + l - 1]);
                /////////////////////////////////////////////////
                // 拓展 1.2
                if (f[i][i + l] == f[i + 1][i + l]) {
                    mark[i][i + l] = 0;
                } else {
                    mark[i][i + l] = 1;
                }
                /////////////////////////////////////////////////

                if (s.charAt(i) == s.charAt(i + l)) {
                    f[i][i + l] = Math.max(f[i][i + l], f[i + 1][i + l - 1] + 2);
                }
                /////////////////////////////////////////////////
                // 拓展 1.3
                if (f[i][i + l] == f[i + 1][i + l - 1] + 2) {
                    mark[i][i + l] = 2;
                }
                /////////////////////////////////////////////////
            }
        }
        /////////////////////////////////////////////////
        // 拓展 1.4
        char[] res = new char[f[0][n - 1]];
        // 结果
        int p = 0, q = f[0][n - 1] - 1;
        // 遍历s
        int i = 0, j = n - 1;
        while (i <= j) {
            if (i==j){
                // 如果长度已经是1了，那么
                res[p]=s.charAt(i);
                break;
            }
            // 长度是2
            if(i+1==j){
                res[p]=s.charAt(i);
                res[q]=s.charAt(j);
                break;
            }
            if (mark[i][j] == 0) {
                // 即f[i][j]==f[i+1][j]
                i++;
            } else {
                if (mark[i][j] == 1) {
                    j--;
                } else {
                    if (mark[i][j] == 2) {
                        res[p++] = s.charAt(i++);
                        res[q--] = s.charAt(j--);
                    }
                }
            }
        }

        Arrays.asList(res).forEach(System.out::print);
        /////////////////////////////////////////////////
        return f[0][n - 1];
    }

}

```

#### lintcode 396 硬币排成线 III

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211214200628042.png" alt="image-20211214200628042" style="zoom:50%;" />

==设`f[i][j]`为一方面对`a[i...j]`时的，能得到的与对手的最大数字差==

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211214201019962.png" alt="image-20211214201019962" style="zoom:50%;" />

```java
public boolean firstWillWin(int[] values) {
    // write your code here
    int n = values.length;
    int[][] f = new int[n][n];
    for (int i = 0; i < n; i++) {
        f[i][i] = values[i];
    }

    for (int l = 1; l < n; l++) {
        for (int i = 0; i + l < n; i++) {
            // f[i][i+l]=max(a[i]-f[i+1][i+l],a[i+l]-f[i][i+l-1]))
            f[i][i + l] = Math.max(values[i] - f[i + 1][i + l], values[i + l] - f[i][i + l - 1]);
        }
    }
    return f[0][n-1]>=0;
}
```

#### lintcode 430 攀爬字符串

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211215214133524.png" alt="image-20211215214133524" style="zoom:50%;" />



<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211215214205138.png" alt="image-20211215214205138" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211215214225786.png" alt="image-20211215214225786" style="zoom:50%;" />

假设字符串`T`和字符串`S`，如果`T`和`S`长度不一样，肯定`T`不能由`S`变换而来。

如果`T`由`S`变换而来，那么由于`T=T1T2`,`S=S1S2`

所以要么`T1`由`S1`变换而来，`T2`由`S2`变换而来；

或者`T1`由`S2`变换而来，`T2`由`S1`变换而来

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211215214842756.png" alt="image-20211215214842756" style="zoom:50%;" />

==状态：`f[i][j][k][h]`表示`T[k...h]`是否由`S[i,...j]`变换而来==

但是对于`T`和`S`，由于其长度一样，所以可以减少一个维度

==即：设`f[i][j][l]`表示为`Si`是否能变换成`Tj`,`i,j`为起始位置各自的起始位置，`l`表示长度==
$$
f[i][j][l]=\{{OR}_{1<=k<=l-1}\{f[i][j][k] AND f[i+k][j+k][l-k]\}\}\\
OR\\
\{{OR}_{1<=k<=l-1}\{f[i][j+k][k] AND f[i+k][j][l-k]\}
$$
==初始条件：如果`S[i]=T[j]`,那么`f[i][j][1]=true`，否则`f[i][j][1]=false`==

计算顺序还是按照长度来计算

==最终的答案是`f[0][0][n]`(因为n表示长度)==

```java
public class Solution {
    /**
     * @param s1: A string
     * @param s2: Another string
     * @return: whether s2 is a scrambled string of s1
     */
    public boolean isScramble(String s1, String s2) {
        // write your code here
        int n=s1.length();
        int m=s2.length();
        if(m!=n){
            return false;
        }

        boolean [][][]f=new boolean[n][n][n+1];

        //初始化 
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                f[i][j][1]=(s1.charAt(i)==s2.charAt(j));
            }
        }

        // 从长度2开始
        for(int l=2;l<=n;l++){
            for(int i=0;i<=n-l;i++){
                for(int j=0;j<=n-l;j++){
                    f[i][j][l]=false;
                    for(int k=1;k<l;k++ ){
                        if(f[i][j][k]&&f[i+k][j+k][l-k]){
                            f[i][j][l]=true;
                            break;
                        }
                        if(f[i][j+l-k][k]&&f[i+k][j][l-k]){
                            f[i][j][l]=true;
                            break;
                        }
                    }  
                }
            }
        }


        return f[0][0][n];
    }
}
```

#### lintcode 168 吹气球

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211216204728673.png" alt="image-20211216204728673" style="zoom:50%;" />

比较正确的思路：

永远是考虑最后一步，这里则为最后一个吹的气球，设编号为`i`

此时气球`1~i-1`以及`i+1~N`都已经吹过，并且获得最后的金币

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211216205041044.png" alt="image-20211216205041044" style="zoom:50%;" />

我们可以显而易见的发现第`i`个气球==左边的情况==和第`i`个气球==右边的情况独立==

也就是吹最后一个气球`i`的时候，依赖于==两个独立的事件:==

1. ==吹`1~i-1`的气球的事件发生==
2. ==吹`i+1~n`的气球的事件发生==

==以上也就是子问题==

==**状态：设`f[i][j]`为吹气球`i+1~j-1`号气球，获得的最多金币数**==

为什么从`i+1~j-1`

解释：因为==把两个边划出去才能保证区间独立==，即我们计算的区间永远是==开区间`(i,j)`==中得到的最大金币数，如此可以==保证各个区间独立==。且结果显而易见应该为`f[0][n+1]`，即吹第`0`个和第`n+1`个气球之间的最大金币数
$$
f[i][j]=max_{i<k<j}\{f[i][k]+f[k+1][j]+nums[i]*nums[k]*nums[j]\}
$$
初始条件：`f[0][1]=f[1][2]=...f[n][n+1]=0`,因为按照定义，无气球可吹。

同样是按照长度去计算。

```java
public class Solution {
    /**
     * @param nums: A list of integer
     * @return: An integer, maximum coins
     */
    public int maxCoins(int[] nums) {
        // write your code here
        if(null==nums||nums.length==0){
            return 0;
        }
        int n=nums.length;

        // 因为多了左右两边两个假想气球
        // 注意需要对左边右边各加一个气球，所以需要对nums进行扩容
        // 不然会越界
        int [] arr=new int[n+2];
        arr[0]=arr[n+1]=1;
        for(int i=0;i<n;i++){
            arr[i+1]=nums[i];
        }


        int [][]f=new int[n+2][n+2];
        for(int i=0;i<n+1;i++){
            f[i][i+1]=0;
        }

        // 长度2开始
        for(int l=2;l<=n+1;l++){
            for(int i=0;i+l<n+2;i++){
                // j=i+l
                f[i][i+l]=Integer.MIN_VALUE;
                // 在(i,i+l)中选择k
                for(int k=i+1;k<i+l;k++){
                    f[i][i+l]=Math.max(f[i][i+l],f[i][k]+f[k][i+l]+arr[i]*arr[k]*arr[i+l]);
                }
            }
        }
        // 小标0表示第0个，下标1代表第一个，n+1表示第n+1个
        return f[0][n+1];
    }
}
```



### 7.8 双序列型动态规划

即有两个序列/字符串

#### lintcode 77 最长公共子序列

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20210730101303067-1630858110894.png" alt="image-20210730101303067" style="zoom: 50%;" />

设`A`的程度为`m`,`B`的长度为`n`，观察`A[m-1]`和`B[n-1]`的两个字符串是否在一个对子中

==子问题==

要求`A[0...m-1]`和`B[0...n-2]`的最长公共子串，`A[0...m-2]`和`B[0...n-1]`的最长公共子串和`A[0...m-2]`和`B[0...n-2]`的最长公共子串

==而原本是要求`A[0...m-1]`和`B[0...n-1]`的最长公共子串==

==为什么没有`A[0...m-2]`和`B[0...n-2]`的最长公共子串==

因为`A[0...m-1]`和`B[0...n-2]`和`A[0...m-2]`和`B[0...n-1]`中已经暗含了

<font color=red>状态</font>：设`f[i][j]`为`A`前i个字符`A[0..i-1]`和`B`前j个字符`[0..j-1]`的最长公共子串的长度

`f[i][j]=max{f[i-1][j],f[i][j-1],f[i-1][j-1]+1|A[i-1]=B[i-1]}`

<font color=red>所以也就是子问题难定</font>

```java
public class Solution {
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    public int longestCommonSubsequence(String A, String B) {
        // write your code here
        int m=A.length();
        int n=B.length();

        int [][] f=new int[m+1][n+1];

        for(int i=0;i<m+1;i++){
            for(int j=0;j<n+1;j++){
                if(i==0||j==0){
                    f[i][j]=0;
                }
            }
        }

        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                f[i][j]=Math.max(f[i-1][j],f[i][j-1]);
                if(A.charAt(i-1)==B.charAt(j-1)){
                    f[i][j]=Math.max(f[i][j],f[i-1][j-1]+1);
                }
            }
        }

        return f[m][n];

    }
}
```

#### lintcode 29 交错字符串

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211217223930023.png" alt="image-20211217223930023" style="zoom: 50%;" />

`s3`长度肯定要是`s1`和`s2`长度之和

和最长公共子序列那一题相比，都是去考虑==两个字符串的最后一个==来==生成子问题的==。

诚然，双序列型动态规划永远是==开二维数组==

我们令==`f[i][j]`为`s1`的前`i`个和`s2`的前`j`个是否能生成`s3`的前`i+j`个字符串==
只有两种true的情况：

1. `s3[i+j-1]=s1[i-1]`,且`f[i-1][j]`为true(即`s3`的第`i+j`个字符的最后一个来自于`s1[i-1]`,在这种情况下，只要`s1`的前`i-1`个字符与`s2`的前`j`个字符能够交叉形成`s3`的前`i-1+j`个字符即可)
2. `s3[i+j-1]=s2[j-1]`,且`f[i][j-1]`为true(类似1)

综述：

`f[i][j]=(f[i-1][j] AND s3[i+j-1]=s1[i-1]) OR (f[i][j-1] AND s3[i+j-1]=s2[j-1])`

```java
public class Solution {
    /**
     * @param s1: A string
     * @param s2: A string
     * @param s3: A string
     * @return: Determine whether s3 is formed by interleaving of s1 and s2
     */
    public boolean isInterleave(String s1, String s2, String s3) {
        // write your code here
        int m=s1.length();
        int n=s2.length();
        if(m+n!=s3.length()){
            return false;
        }

        boolean [][] f=new boolean[m+1][n+1];
        
        for(int i=0;i<m+1;i++){
            for(int j=0;j<n+1;j++){
                if(i==0&&j==0){
                    f[i][j]=true;
                }
                if(i>0 &&s3.charAt(i+j-1)==s1.charAt(i-1)){
                    f[i][j]|=f[i-1][j];
                }
                if(j>0&& s3.charAt(i+j-1)==s2.charAt(j-1)){
                    f[i][j]|=f[i][j-1];
                }
            }
        }
        return f[m][n];
    }
}
```

#### lintcode 119 编辑距离

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211219204412966.png" alt="image-20211219204412966" style="zoom:50%;" />

设`A`长度是`m`,`B`长度是`n`

其实==最优策略（或者合法策略）都是将`A`的最后一个字符变成`B`的最后一个字符==

==情况一==，在`A`的最后<font color=red>插入</font>`B[n-1]`，则考虑的==子问题就是将`A[0...m-1]`变成`B[0...n-2]`==

==情况二==，将`A`的最后一个字符<font color=red>替换</font>成`B[n-1]`,则考虑的==子问题就是将`A[0...m-2]`变成`B[0...n-2]`==

==情况三==，<font color=red>删除</font>A的最后一个字符,则考虑的==子问题是将`A[0...m-2]`变成`B[0...n-1]`==

==情况四==，<font color=red>`A[m-1]`与`B[n-1]`相等</font>，则考虑的==子问题就是将`A[0...m-2]`变成`B[0...n-2]`==

<font color=red>设`f[i][j]`为前`i`个字符`A[0...i-1]`和`B[0...j-1]`的最小编辑距离</font>

`f[i][j]=min{f[i][j-1]+1,f[i-1][j-1]+1,f[i-1][j]+1,f[i-1][j-1]|A[i-1]==B[j-1]}`

初始条件,一个空串的编辑距离是另一个字符串的长度：

即`f[0][j]=j`，`f[i][0]=i`

计算顺序不是按照长度来，记住，不要和区间动态规划混淆。

```java
public class Solution {
    /**
     * @param word1: A string
     * @param word2: A string
     * @return: The minimum number of steps.
     */
    public int minDistance(String word1, String word2) {
        // write your code here
        if((word1==null||word1.length()==0)){
            return (word2==null||word2.length()==0)?0:word2.length();
        }

        if((word2==null||word2.length()==0)){
            return word1.length();
        }

        // f[i][j]=min{f[i][j-1]+1,f[i-1][j-1]+1,f[i-1][j]+1,f[i-1][j-1]|A[i-1]==B[j-1]}
        int m=word1.length();
        int n=word2.length();
        int [][]f=new int[m+1][n+1];
        for(int i=0;i<m+1;i++){
            f[i][0]=i;
        }
        for(int j=0;j<n+1;j++){
            f[0][j]=j;
        }
        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                // 注意，因为开的长度+1了，所以要注意其对应关系，i=1表示的是第一个字符，
                // 但对应于字符串下标是i-1
                f[i][j]=Math.min(Math.min(f[i][j-1],f[i-1][j-1]),f[i-1][j])+1;
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    f[i][j]=Math.min(f[i][j], f[i-1][j-1]);
                }
            }
        }
        return f[m][n];
    }
}
```

####  lintcode 118 不同的子序列

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211220205318660.png" alt="image-20211220205318660" style="zoom:50%;" />

和最长公共子序列的想法类似，但由于T的长度短，必须由T出发

情况一：`T[n-1]=S[m-1]`,则求的是`T[n-2]`在`S[m-2]`中出现了多少次

情况二：`T[n-1]不和S[m-1]`结成对子，求的是`T[0...n-1]`在`S[m-2]`中出现了多少次

状态：设`f[i][j]`为`T`的前`j`个字符在`S`的前`i`个字符中出现了多少次

则`f[i][j]=f[i-1][j-1]|S[i-1]=T[j-1]+f[i-1][j]`

初始条件：如果`T`是空串，则`T`在`S`中出现的次数是1，而不是0

如果`S`是空串，`T`不是，那么`T`在`S`中出现的次数为0

```java
public class Solution {
    /**
     * @param S: A string
     * @param T: A string
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        // write your code here
        // f[i][j]=f[i-1][j-1]|S[i-1]=T[j-1]+f[i-1][j]

        if(S==null||S.length()==0){
            if(T==null||T.length()==0){
                return 1;
            }else{
                return 0;
            }
        }
        
        int m=S.length();
        int n=T.length();
        int [][] f=new int[m+1][n+1];
        
        // 初始化T的长度为0的情况
        for(int i=0;i<m+1;i++){
            f[i][0]=1;
        }
        // S的长度为0的情况默认为0，无需初始化
        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                f[i][j]=f[i-1][j];
                if(S.charAt(i-1)==T.charAt(j-1)){
                    f[i][j]+=f[i-1][j-1];
                }
            }
        }

        return f[m][n];
    
    }
}
```

#### lintcode 154 正则表达式匹配

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211221210758090.png" alt="image-20211221210758090" style="zoom:50%;" />

假设B的最后一个字符不是`.`，也不是`*`,在`A[m-1]=B[n-1]`的情况下，匹配情况取决于`A[0..m-2]`于`B[0..n-2]`

假设B的最后一个字符是`.`，那么也是直接取决于`A[0..m-2]`与`B[0..n-2]`的匹配情况；

假设B的最后一个字符是`*`，则表示的是`A`需要匹配`B[n-2]`0次或者若干次

- 如果`A[m-1]!=B[n-2]`,则取决于`A[0..m-1]`与`B[0..n-3]`的匹配情况 

- 如果`A[m-1]=B[n-2]`或者`B[n-2]=.`,则取决于`A[0..m-2]`与`B[0..n-1]`的匹配情况

==状态==：设`f[i][j]`为`A`的前`i`个字符与`B`的前`j`个字符是否匹配

则==状态转移方程==为

- `f[i][j]=f[i-1][j-1]`，当`A[i-1]=B[j-1]`且`B[j-1]不是*时` 或者`B[j-1]`是`.`时

- `f[i][j]=f[i][j-2]`，当`A[i-1]!=B[j-2]`,且`B[j-1]`是`*`时

- `f[i][j]=f[i-1][j]`，当`A[i-1]=B[j-2](或者B[j-2]=.)`,且`B[j-1]`是*时

初始条件

`f[0][0]=true`

`f[1][0]=f[2][0]=...f[m][0]=false`

注意，==`f[0][1..n]`也需要用动态规划进行计算==，但是==只能用`f[i][j-2]`，因为没有`A`元素存在==

```java
public class Solution {
    /**
     * @param s: A string
     * @param p: A string includes "." and "*"
     * @return: A boolean
     */
    public boolean isMatch(String s, String p) {
        // write your code here
        if (p == null || p.length() == 0) {
            return s == null || s.length() == 0;
        }

        int m = s.length();
        int n = p.length();
        boolean[][] f = new boolean[m + 1][n + 1];

        f[0][0] = true;

        // f[1][0]=...f[m][0]=false默认已经赋值

        for (int i = 0; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (i == 0) {
                    // 计算f[0][1..n] f[0][1]=false;
                    if (j > 1) {
                        if (p.charAt(j - 1) == '*') {
                            f[i][j] = f[i][j - 2];
                        }
                    }
                    continue;
                }


                // i>0 j>=1
                if (p.charAt(j - 1) != '*') {
                    if (s.charAt(i - 1) == p.charAt(j - 1) 
                            || p.charAt(j - 1) == '.') {
                        f[i][j] = f[i - 1][j - 1];
                        continue;
                    }

                }


                if (j > 1) {
                    if (p.charAt(j - 1) == '*' 
                            && s.charAt(i - 1) != p.charAt(j - 2)) {
                        f[i][j] |= f[i][j - 2];

                    }
                    if (p.charAt(j - 1) == '*' 
                            && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                        f[i][j] |= f[i - 1][j];
                    }
                }

            }
        }
        return f[m][n];

    }

}


```

#### lintcode 192 通配符匹配

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211222212655592.png" alt="image-20211222212655592" style="zoom:50%;" />

假设B的最后一个字符不是`?`，也不是`*`,在`A[m-1]=B[n-1]`的情况下，匹配情况取决于`A[0..m-2]`于`B[0..n-2]`

假设B的最后一个字符是`?`，那么也是直接取决于`A[0..m-2]`与`B[0..n-2]`的匹配情况；

假设B的最后一个字符是`*`，则==需要考虑`A[m-1]`是否被`*`匹配==

- 如果`A[m-1]`==被匹配==,则取决于`A[0..m-2]`与`B[0..n-1]`的匹配情况（==因为`*`可以匹配若干个字符==） 

- 如果`A[m-1]`==不被匹配==,则取决于`A[0..m-1]`与`B[0..n-2]`的匹配情况（==索性不匹配，`*`不起作用的情况下==）

==状态==：设`f[i][j]`为`A`的前`i`个字符与`B`的前`j`个字符是否匹配

==状态转移方程：==

`f[i][j]=f[i-1][j-1]`当`B[j]`不是`*`,且`A[i-1]=B[j-1]`或者`B[j-1]=?`

`f[i][j]=f[i-1][j] OR f[i][j-1]`当`B[j]`是`*`时

==初始状态==

`f[0][0]=true`

`f[1][0]=f[2][0]=...f[m][0]=false`

`f[0][1...n]`也需要动态规划算，只能用`f[i][j-1]`,所以必须有通配符为`*`

```java
public class Solution {
    /**
     * @param s: A string
     * @param p: A string includes "?" and "*"
     * @return: is Match?
     */
    public boolean isMatch(String s, String p) {
        // write your code here
        if(null==p||p.length()==0){
            return s==null||s.length()==0;
        }
        int m=s.length();
        int n=p.length();
        boolean[][] f=new boolean[m+1][n+1];

        f[0][0]=true;
        // f[1...m][0]=false;
        for(int i=0;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                // 求f[0][1...n]
                if(i==0){
                    if(p.charAt(j-1)=='*'){
                        f[i][j]=f[i][j-1];
                    }
                    continue;
                }

                // i>0 j>0
                if(p.charAt(j-1)!='*'){
                    if(p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)=='?'){
                        f[i][j]=f[i-1][j-1];
                    }
                }else{
                    f[i][j]|=f[i-1][j];
                    f[i][j]|=f[i][j-1];
                }
            }
        }

        return f[m][n];
    }
}

```

### 7.9 每日一题

##### 1. 剑指 Offer II 100. 三角形中最小路径之和(坐标型)

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211223214950921.png" alt="image-20211223214950921" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211228215846210.png" alt="image-20211228215846210" style="zoom: 50%;" />

典型的坐标型动态规划，即假设当前项满足该性质，并在该性质上得到转移方程。

```java


class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        //     假设走到这个数的和最小triangle.get(i).get(j)
        //     所以是二维的？
        //     f[i][j]=min(f[i-1][j],f[i-1][j-1])+triangle.get(i).get(j)
        //     然后取个最小值     注意一定要走到最后一列

        //     数组的长度即为list的深度和最大宽
        //     这是一个坐标型动态规划
        int depth = triangle.size();
        int width = 0;
        for (int i = 0; i < depth; i++) {
            width = Math.max(width, triangle.get(i).size());
        }

        int[][] f = new int[depth][width];

        f[0][0]=triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            List<Integer> row = triangle.get(i);
            for (int j = 0; j < row.size(); j++) {
                f[i][j] = f[i - 1][j];
                if (j > 0) {
                    f[i][j] = Math.min(f[i][j], f[i - 1][j - 1]);
                }
                f[i][j] += row.get(j);

                // 注意f[i][i]没有对应的f[i-1][i]  因为上面的那一行没有到i 我竟然错在这里，服了
                if(i==j){
                    f[i][i]=f[i-1][i-1]+row.get(i);
                }  
            }
        }

        int res = Integer.MAX_VALUE;
        for (int i = 0; i < width; i++) {
            res = Math.min(res, f[depth - 1][i]);
        }
        return res;
    }
}
```

==注意以上，我竟然错在了`f[i][i]`的边界条件上==

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // wocao
        // wocao
        // wocao 这tmd是个背包问题
        // 前i个字母（影射重量）是否能由前j个word拼成（即前j个物品是否能拼成重量i）
        // 最后一步 第j个word是否要参与贡献
        // 不参加贡献 前j-1个就能了 即为f[i][j-1]，即第j个word一个都不需要
        //  尚需一个, f[i-len(j)][j] （i-len(j)到i之间的词刚好是第j个word时）

        int m=s.length();
        int n=wordDict.size();
        boolean [][] f=new boolean [m+1][n+1];
        
        for(int i=0;i<n+1;i++){
            f[0][i]=true;
        }
        // f[1..m][0]=false;

        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                String tmp=wordDict.get(j-1);
                f[i][j]=f[i][j-1];
                if(i-tmp.length()>=0){
                    if(s.substring(i-tmp.length(),i).equals(tmp)){
                        f[i][j]=f[i][j]||f[i-tmp.length()][j];
                    }
                }
            }
        }

        return f[m][n];


     

    }
}
```

##### 2. leetcode 139 单词拆分（划分型）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211227234547278.png" alt="image-20211227234547278" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211228215935253.png" alt="image-20211228215935253" style="zoom:50%;" />

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 既然是拆分，那就是划分型，将序列划分为各段，每段是否出现在字典表中
        // 既然是拆分，那就是划分型，将序列划分为各段，每段是否出现在字典表中
        // 既然是拆分，那就是划分型，将序列划分为各段，每段是否出现在字典表中
        // 既然是拆分，那就是划分型，将序列划分为各段，每段是否出现在字典表中
        // 暂时不要用九章算法的完全背包思路去解  因为有点难以理解
        // 好吧 可能那种思路我错在哪个地方了  不会
        Set<String> wordDictSet = new HashSet<>(wordDict);
        // f[i]=f[j]&&[j..i-1]出现在字典中（j=0,..,i-1）
        boolean[] f = new boolean[s.length() + 1];
        f[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                // // f[i]=f[j]&&[j..i-1]出现在字典中（j=0,..,i-1）
                if (f[j] && wordDictSet.contains(s.substring(j, i))) {
                    f[i] = true;
                    break;
                }
            }
        }
        return f[s.length()];
    }
}

```

##### 3. leetcode 91 解码方法（序列型）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211228213757701.png" alt="image-20211228213757701" style="zoom:67%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211228214055023.png" alt="image-20211228214055023" style="zoom: 50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211228220001705.png" alt="image-20211228220001705" style="zoom:50%;" />

```java
class Solution {
    public int numDecodings(String s) {
        if(s==null||s.length()==0||s.charAt(0)=='0'){
            return 0;
        }

        int n=s.length();
        int [] f=new int[n+1];
        // f[2]=f[1]|第二个是字母+f[0]|第一第二个是合法字母 所以f[0]=1
        f[0]=1;
        for(int i=1;i<n+1;i++){
            if(s.charAt(i-1)>='1' && s.charAt(i-1)<='9'){
                f[i]+=f[i-1];
            }
            if(i>1){
                int val=Integer.parseInt(s.substring(i-2,i));
                if(s.charAt(i-2)!='0'&& val>=10 && val<=26){
                    f[i]+=f[i-2];
                }
            }
        }

        return f[n];
    }

    
}
```

##### 4. leetcode 1043 分隔数组的最大和(数学归纳法)

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211230011221116.png" alt="image-20211230011221116" style="zoom:50%;" />

```java
class Solution {
    public int maxSumAfterPartitioning(int[] arr, int k) {
        int n = arr.length;
        int[] f = new int[n];
        for (int i = 1; i <= k; i++) {
            f[i - 1] = getMaxValue(arr, 0, i - 1) * i;
        }
        // 状态定义 即面对前i个数的最大值
        // 状态转移方程即  由数学归纳法进行推导
        // 由此得到划分型动态规划与数学归纳法的莫大关系
        // max(f[i-1]+max(arr[i-1])*1,f[i-2]+max(arr[i-1],arr[i-2])*2
        //              ,...f[i-k]+max(arr[i-1],... arr[i-k])*k))
        for (int i = k; i < n; i++) {
            f[i]=Integer.MIN_VALUE;
            for (int j = 1; j <= k; j++) {
                // 我擦  是从f[i-1]算起  因为f[i-1]已经计算了
                // 我擦  是从f[i-1]算起  因为f[i-1]已经计算了
                // 我擦  是从f[i-1]算起  因为f[i-1]已经计算了
                f[i] = Math.max(f[i - j]
                        + getMaxValue(arr, i - j + 1, i) * j, f[i]);
            }
        }
        return f[n - 1];
    }

    private int getMaxValue(int[] arr, int start, int end) {
        int res = Integer.MIN_VALUE;
        for (int i = start; i <= end; i++) {
            res = Math.max(res, arr[i]);
        }
        return res;
    }
}


```

##### 5. leetcode 264 丑数II（数学归纳法）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20211230222933819.png" alt="image-20211230222933819" style="zoom:67%;" />

```java
class Solution {
    public int nthUglyNumber(int n) {

        // f[1]=1

        // 用三个指针 p2 p3 p5指向现在的第i个位置  刚开始指向的是1
        // f[2]=min(f[p2]*2,f[p3]*3,f[p5]*5)=2

        // 上面三个指针指的是使得f[pj]*j（j=2,3,5）大于f[i-1]的最小下标

        int [] f=new int[n+1];
        f[1]=1;
        int p2=1,p3=1,p5=1;
        for(int i=2;i<n+1;i++){
            f[i]=Math.min(f[p2]*2,Math.min(f[p3]*3,f[p5]*5));

            // 然后分别去把f[i]与上面的f[p2]*2,f[p3]*3,f[p5]*5相比较
            // 如果相等则将对应的指针加1，该类型的迭代从此重新开始
            // 然后重新一轮的比较  这逻辑好牛啊 牛逼
            // 数学归纳法yyds  这里用三个指针是真的牛逼
            // 在一轮轮的指针指针变换中，得以将丑数排序  
            // 妙啊妙
            if(f[i]==f[p2]*2){
                p2++;
            }
            if(f[i]==f[p3]*3){
                p3++;
            }
            if(f[i]==f[p5]*5){
                p5++;
            }
        }

        return f[n];
    }
}
```

##### 6. leetcode 152 乘积最大子数组（与最大子序和类似但不完全是）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101143846694.png" alt="image-20220101143846694" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101144154061.png" alt="image-20220101144154061" style="zoom:50%;" />

```java


class Solution {
    public int maxProduct(int[] nums) {

        // 以f[i][0]表示以第i个数结尾的最小乘积
        // 以f[i][1]表示以第i个数结尾的最大乘积

        // 显然  我们要求的是max(f[i][1]) i=0,...n-1
        // 并且f[i][0]与前一组的定义的关系为
        // f[i][0]=min(min(f[i-1][0]*nums[i],f[i-1][1]*nums[i]),nums[i])
        // f[i][1]=max(max(f[i-1][0]*nums[i],f[i-1][1]*nums[i]),nums[i])
        // 解释： 因为不能确定这次是与前面的最大值（或最小值）是同号还是异号，
        // 且不能确定f[i-1][0] f[i-1][1]符号相同，且一直与num[i]异号 则取nums[i]
        // 但如果不是  则一个max生效

        int n=nums.length;
//    未精简空间代码     int [][] f=new int[n][2];
//    未精简空间代码     f[0][0]=f[0][1]=nums[0];
        int prevMin=nums[0];
        int prevMax=nums[0];
        int max=nums[0];
        for(int i=1;i<n;i++){
//   未精简空间代码         f[i][0]=Math.min(Math.min(f[i-1][0]*nums[i],f[i-1][1]*nums[i]),nums[i]);
            // 注意必须有下面两个变量来缓存，不然两者计算时用到的prevMin
            // prevMax不一致
            int tmpPrevMin=prevMin*nums[i];
            int tmpPrevMax=prevMax*nums[i];
            prevMin=Math.min(Math.min(tmpPrevMin,tmpPrevMax),nums[i]);
//            f[i][1]=Math.max(Math.max(f[i-1][0]*nums[i],f[i-1][1]*nums[i]),nums[i]);
            prevMax=Math.max(Math.max(tmpPrevMin,tmpPrevMax),nums[i]);
//   未精简空间代码          max=Math.max(max,f[i][1]);
            max=Math.max(max,prevMax);
        }

        return max;


    }
}
```

##### 7. leetcode 121 买卖股票的最佳时机(只买卖一次)

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101151717950.png" alt="image-20220101151717950" style="zoom:67%;" />

```java
class Solution {
    public int maxProfit(int[] prices) {

        // 这的确是简单问题
        // 不会很过分 真的
        // 也就是要找出每一次卖出之前的最小值
        // 并拿到最大收益即可
       
        int n=prices.length;
        int minV=prices[0];
        int res=0;
        for(int i=1;i<n;i++){
            res=Math.max(res,prices[i]-minV);
            minV=Math.min(minV,prices[i]);
        }

        return res;

    }
}
```

##### 8. leetcode 122 买卖股票的最佳时机II（买卖多次）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101152808657.png" alt="image-20220101152808657" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101152838487.png" alt="image-20220101152838487" style="zoom: 33%;" />

```java
class Solution {
    public int maxProfit(int[] prices) {
        int result = 0;
        for (int i = 1; i < prices.length; i++) {
            // 把利润分解为每天为单位的维度
            // 收集能涨的
            result += Math.max(prices[i] - prices[i - 1], 0);
        }
        return result;

    }
}
```

##### 9. leetcode 123 买卖股票的最佳时机III（买卖两次）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101153953438.png" alt="image-20220101153953438" style="zoom:50%;" />

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101154547761.png" alt="image-20220101154547761" style="zoom:50%;" />

最优策略一定是处于

==阶段一==：没买过

==阶段三==：买卖过一次

==阶段五==：买卖过两次

<font color=red>阶段五</font>

对于前`N`天，如果第`N-1`天处于==阶段五==，且==前一天（即第`N-2`天）==也处于==阶段五==，那么`f[N][5]=f[N-1][5]`

如果==前一天（即第`N-2`天）==处于==阶段四==，今天才卖第二次，则`f[N][5]=f[N-1][4]+price[N-1]-price[N-2]`

<font color=red>阶段三</font>

对于前`N`天，如果第`N-1`天处于==阶段三==，且==前一天（即第`N-2`天）==也处于==阶段三==，那么`f[N][3]=f[N-1][3]`

如果==前一天（即第`N-2`天）==处于==阶段二==，今天才卖第一次，则`f[N][3]=f[N-1][2]+price[N-1]-price[N-2]`

<font color=red>其他阶段类似</font>

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101160651556.png" alt="image-20220101160651556" style="zoom:50%;" />

<font color=red>初始状态</font>

`f[0][1]=0`

$f[0][2]=f[0][3]=...=f[0][5]=-\infty$

答案是`max{f[N][1],f[N][3],f[N][5]}`

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int n = prices.length;

        // 因为有五种状态
        int[][] f = new int[n + 1][5 + 1];

        f[0][1] = 0;
        for (int i = 2; i < 6; i++) {
            f[0][i] = Integer.MIN_VALUE;
        }
        for (int i = 1; i < n + 1; i++) {
            // 阶段一 三 五
            // f[i][j]=max{f[i-1][j],f[i-1][j-1]+prices[i-1]-prices[i-2]}
            for (int j = 1; j < 6; j += 2) {
                f[i][j] = f[i - 1][j];
                if (i > 1 && j > 1 && f[i - 1][j - 1] != Integer.MIN_VALUE) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]);
                }
            }

            for (int j = 2; j < 6; j += 2) {
                // 阶段二 四
                // f[i][j]=max{f[i-1][j]+prices[i-1]-prices[i-2],f[i-1][j-1]}
                f[i][j] = f[i - 1][j - 1];
                if (i > 1 && f[i - 1][j] != Integer.MIN_VALUE) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]);
                }

            }


        }

        return Math.max(Math.max(f[n][1], f[n][3]), f[n][5]);
    }
}
```

##### 10. leetcode 188 买卖股票的最佳时机IV（买卖K次）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220101171933250.png" alt="image-20220101171933250" style="zoom:67%;" />

```java
class Solution {
    public int maxProfit(int k,int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int n = prices.length;

        if(k>n/2){
            int sum=0;
            for(int i=0;i<n-1;i++){
                if(prices[i+1]>prices[i]){
                    sum+=prices[i+1]-prices[i];
                }
            }
            return sum;
        }

        // 因为有2k+1种状态
        int[][] f = new int[n + 1][2*k + 2];

        f[0][1] = 0;
        for (int i = 2; i < 2*k+2; i++) {
            f[0][i] = Integer.MIN_VALUE;
        }
        for (int i = 1; i < n + 1; i++) {
            // 阶段一 三 五 ...
            // f[i][j]=max{f[i-1][j],f[i-1][j-1]+prices[i-1]-prices[i-2]}
            for (int j = 1; j < 2*k+2; j += 2) {
                f[i][j] = f[i - 1][j];
                if (i > 1 && j > 1 && f[i - 1][j - 1] != Integer.MIN_VALUE) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + prices[i - 1] - prices[i - 2]);
                }
            }

            for (int j = 2; j < 2*k+2; j += 2) {
                // 阶段二 四...
                // f[i][j]=max{f[i-1][j]+prices[i-1]-prices[i-2],f[i-1][j-1]}
                f[i][j] = f[i - 1][j - 1];
                if (i > 1 && f[i - 1][j] != Integer.MIN_VALUE) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j] + prices[i - 1] - prices[i - 2]);
                }

            }
        }

        int max=Integer.MIN_VALUE;
        for(int i=1;i<2*k+2;i+=2){
            max=Math.max(max,f[n][i]);
        }

        return max;
    }
}
```

##### 11. leetcode313 超级丑数（与丑数II类似）

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220103171344445.png" alt="image-20220103171344445" style="zoom:67%;" />

```java


class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {

        // 与丑数II的区别在于  这里的质数是个数组  而不是定死了
        // 所以每个质数都有一个指针
        int [] f=new int[n+1];
  

        int m=primes.length;
        // 存一个指针表示该prime各个质数到达的位置
        int [] pointer=new int [m];
        // 存prime其代表的质数的当前最大值
        int[] nums = new int[m];
        Arrays.fill(nums, 1);

        for(int i=1;i<n+1;i++){
            // 必须保证从最小值开始
            int minNum = Arrays.stream(nums).min().getAsInt();
            f[i]=minNum;
            for(int j=0;j<m;j++){
                if(minNum==nums[j]){
                    pointer[j]++;
                    nums[j]=f[pointer[j]]*primes[j];
                }
            }
        }

        return f[n];


    }
}
```

##### 12. leetcode 213 打家劫舍II

围成一个圈的打家劫舍

```java
class Solution {
    public int rob(int[] nums) {

        if (nums == null || nums.length == 0) {
            return 0;
        }

        if (nums.length == 1) {
            return nums[0];
        }
        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }

        // 房子0没偷  则变为偷[1,..N-1]的问题
        // 房子N-1 没有偷 则变为偷[0,..N-2]的问题
        int[] preNums = new int[nums.length - 1];
//        for (int i = 0; i < nums.length - 1; i++) {
//            preNums[i] = nums[i];
//        }
        // 数组copy竟然都不会 菜
        System.arraycopy(nums, 0, preNums,
                0, nums.length - 1);

        int[] afterNums = new int[nums.length - 1];
        System.arraycopy(nums, 1, afterNums,
                0, nums.length - 1);

        int preRes = robber(preNums);
        int afterRes = robber(afterNums);
        return Math.max(preRes, afterRes);
    }

    private int robber(int[] nums) {
        // f[i][0]表示面对第i栋（nums[i-1]）没有偷时的最大值
        // f[i][1]表示面对第i栋（nums[i-1]）偷了的最大值
        // f[i][0]=max{f[i-1][0],f[i-1][1]}
        // 上面的公式其实就是面对前i-1栋没有偷的最大值
        // f[i][1]=f[i-2][1]+nums[i-1]

        // 所以简化为面对前i栋房子能够获取的最大值
        // f[i]=max(f[i-1],f[i-2]+nums[i-1])

        if (null == nums || nums.length == 0) {
            return 0;
        }
        // write your code here
        int n = nums.length;
        int[] f = new int[n + 1];
        f[0] = 0;
        f[1] = nums[0];


        for (int i = 2; i < n + 1; i++) {
            f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
        }
        return f[n];

    }

}
```

##### 13. leetcode 343 整数拆分

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220105221819080.png" alt="image-20220105221819080" style="zoom:50%;" />

简简单单的推导,`2=1+1`，`f[2]=1*1=1`,`f[3]=1*2`不等于`1*f[2]`,二是等于`1*(3-1)`

所以取二者中最大值

其实这是==划分型动态规划==，设`f[i]`为`i`能够被拆分的最大值，则对于`j属于[1,i)`，

有`f[i]=max(f[j]*(i-j),j*(i-j))`

<img src="%E4%B8%8D%E7%84%B6%E6%B0%B8%E8%BF%9C%E8%BF%87%E4%B8%8D%E5%8E%BB.assets/image-20220105224159478.png" alt="image-20220105224159478" style="zoom:67%;" />

```java
class Solution {
    public int integerBreak(int n) {

    //   `f[i]=max(f[j]*(i-j),j*(i-j))`
    if (n==2){
        return 1;
    }

    int [] f=new int[n+1];
    f[2]=1;
    for(int i=3;i<n+1;i++){
        for(int j=1;j<i;j++){
            f[i]=Math.max(Math.max(f[j]*(i-j),j*(i-j)),f[i]);
        }
    }
     
     return f[n];

    }
}
```

有兴趣的话可以去看==高数解法的题解==，即这是一个函数问题，如果不用动态规划方法求解的话。

## 八、（三星重要）树



## 九、栈和队列

## 十、哈希表

## 十一、字符串

## 十二、数组与矩阵

## 十三、图

## 十四、位运算

